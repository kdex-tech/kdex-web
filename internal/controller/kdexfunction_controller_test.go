package controller

import (
	"context"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	kdexv1alpha1 "kdex.dev/crds/api/v1alpha1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

var _ = Describe("KDexFunction Controller", func() {
	Context("When reconciling a KDexFunction", func() {
		const resourceName = "test-function"
		ctx := context.Background()

		AfterEach(func() {
			cleanupResources(namespace)
		})

		It("should fail if hostRef.name is empty", func() {
			resource := &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-empty-hostref",
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.API{
						BasePath: "/v1/api",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/api/test": {},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Environment: "go-env",
						Language:    "go",
					},
				},
			}

			err := k8sClient.Create(ctx, resource)
			Expect(err).To(HaveOccurred())
			Expect(err.Error()).To(ContainSubstring("hostRef.name must not be empty"))
		})

		It("should fail if basePath does not match regex", func() {
			resource := &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-invalid-basepath",
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					HostRef: corev1.LocalObjectReference{Name: focalHost},
					API: kdexv1alpha1.API{
						BasePath: "/invalid", // only one segment, but regex is ^/\w+/\w+
						Paths: map[string]kdexv1alpha1.PathItem{
							"/invalid/test": {},
						},
					},
				},
			}

			err := k8sClient.Create(ctx, resource)
			Expect(err).To(HaveOccurred())
			Expect(err.Error()).To(ContainSubstring("match"))
		})

		It("should fail if manual function has no language", func() {
			resource := &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-manual-no-lang",
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					HostRef: corev1.LocalObjectReference{Name: focalHost},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: false,
					},
					API: kdexv1alpha1.API{
						BasePath: "/v1/api",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/api/test": {},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Executable:  "oci://some-package",
						Environment: "go-env",
					},
				},
			}

			err := k8sClient.Create(ctx, resource)
			Expect(err).To(HaveOccurred())
			Expect(err.Error()).To(ContainSubstring("spec.function.language: Required value"))
		})

		It("should fail if function has no environment", func() {
			resource := &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-manual-no-pkg",
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					HostRef: corev1.LocalObjectReference{Name: focalHost},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: false,
					},
					API: kdexv1alpha1.API{
						BasePath: "/v1/api",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/api/test": {},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language: "go",
					},
				},
			}

			err := k8sClient.Create(ctx, resource)
			Expect(err).To(HaveOccurred())
			Expect(err.Error()).To(ContainSubstring("spec.function.environment: Required value"))
		})

		It("should not create with invalid JSON OpenAPI", func() {
			resource := &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      resourceName,
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					HostRef: corev1.LocalObjectReference{Name: focalHost},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
					API: kdexv1alpha1.API{
						BasePath: "/v1/api",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/api/test": {
								Get: &runtime.RawExtension{
									Raw: []byte(`{`),
								},
							},
						},
					},
				},
			}

			err := k8sClient.Create(ctx, resource)
			Expect(err).To(HaveOccurred())
			Expect(err.Error()).To(ContainSubstring("json: error calling MarshalJSON for type *runtime.RawExtension: unexpected end of JSON input"))
		})

		It("becomes OpenAPIValid", func() {
			resource := &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      resourceName,
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					HostRef: corev1.LocalObjectReference{Name: focalHost},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
					API: kdexv1alpha1.API{
						BasePath: "/v1/api",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/api/test": {},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Environment: "go-env",
						Language:    "go",
					},
				},
			}

			Expect(k8sClient.Create(ctx, resource)).To(Succeed())

			addOrUpdateInternalHost(
				ctx, k8sClient,
				kdexv1alpha1.KDexInternalHost{
					ObjectMeta: metav1.ObjectMeta{
						Name:      focalHost,
						Namespace: namespace,
					},
					Spec: kdexv1alpha1.KDexInternalHostSpec{
						KDexHostSpec: kdexv1alpha1.KDexHostSpec{
							BrandName:    "KDex Tech",
							ModulePolicy: kdexv1alpha1.LooseModulePolicy,
							Organization: "KDex Tech Inc.",
							Routing: kdexv1alpha1.Routing{
								Domains: []string{
									"kdex.dev",
								},
							},
						},
					},
				},
			)

			assertResourceReady(
				ctx, k8sClient, focalHost, namespace,
				&kdexv1alpha1.KDexInternalHost{}, true)

			Eventually(func(g Gomega) {
				fetched := &kdexv1alpha1.KDexFunction{}
				err := k8sClient.Get(ctx, client.ObjectKey{Name: resource.Name, Namespace: namespace}, fetched)
				g.Expect(err).NotTo(HaveOccurred())
				g.Expect(
					meta.IsStatusConditionTrue(
						fetched.Status.Conditions,
						string(kdexv1alpha1.ConditionTypeDegraded),
					),
				).To(BeTrue())
				g.Expect(
					meta.IsStatusConditionFalse(
						fetched.Status.Conditions,
						string(kdexv1alpha1.ConditionTypeProgressing),
					),
				).To(BeTrue())
				g.Expect(fetched.Status.State).To(Equal(kdexv1alpha1.KDexFunctionStateOpenAPIValid))
			}, "10s", "1s").Should(Succeed())
		})

		It("becomes BuildValid", func() {
			resource := &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      resourceName,
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					HostRef: corev1.LocalObjectReference{Name: focalHost},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
					API: kdexv1alpha1.API{
						BasePath: "/v1/api",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/api/test": {},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Environment: "go-env",
						Language:    "go",
					},
				},
			}

			Expect(k8sClient.Create(ctx, resource)).To(Succeed())

			addOrUpdateInternalHost(
				ctx, k8sClient,
				kdexv1alpha1.KDexInternalHost{
					ObjectMeta: metav1.ObjectMeta{
						Name:      focalHost,
						Namespace: namespace,
					},
					Spec: kdexv1alpha1.KDexInternalHostSpec{
						KDexHostSpec: kdexv1alpha1.KDexHostSpec{
							BrandName:    "KDex Tech",
							ModulePolicy: kdexv1alpha1.LooseModulePolicy,
							Organization: "KDex Tech Inc.",
							Routing: kdexv1alpha1.Routing{
								Domains: []string{
									"kdex.dev",
								},
							},
						},
					},
				},
			)

			assertResourceReady(
				ctx, k8sClient, focalHost, namespace,
				&kdexv1alpha1.KDexInternalHost{}, true)

			faasAdaptor := &kdexv1alpha1.KDexClusterFaaSAdaptor{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "kdex-default-faas-adaptor-knative",
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFaaSAdaptorSpec{
					Provider: "knative",
					Generators: map[string]kdexv1alpha1.GeneratorConfig{
						"go/go-env": {
							Image: "ghcr.io/kdex-dev/kdex-function-generator-go:latest",
						},
					},
				},
			}
			Expect(k8sClient.Create(ctx, faasAdaptor)).To(Succeed())

			Eventually(func(g Gomega) {
				fetched := &kdexv1alpha1.KDexFunction{}
				err := k8sClient.Get(ctx, client.ObjectKey{Name: resource.Name, Namespace: namespace}, fetched)
				g.Expect(err).NotTo(HaveOccurred())
				g.Expect(
					meta.IsStatusConditionTrue(
						fetched.Status.Conditions,
						string(kdexv1alpha1.ConditionTypeDegraded),
					),
				).To(BeTrue())
				g.Expect(
					meta.IsStatusConditionFalse(
						fetched.Status.Conditions,
						string(kdexv1alpha1.ConditionTypeProgressing),
					),
				).To(BeTrue())
				g.Expect(fetched.Status.State).To(Equal(kdexv1alpha1.KDexFunctionStateBuildValid))
			}, "10s", "1s").Should(Succeed())
		})

		It("becomes SourceAvailable", func() {
			resource := &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      resourceName,
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					HostRef: corev1.LocalObjectReference{Name: focalHost},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
					API: kdexv1alpha1.API{
						BasePath: "/v1/api",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/api/test": {},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Environment: "go-env",
						Language:    "go",
						Source: &kdexv1alpha1.Source{
							Repository: "foo",
							Revision:   "bar",
							Path:       "baz",
						},
					},
				},
			}

			Expect(k8sClient.Create(ctx, resource)).To(Succeed())

			addOrUpdateInternalHost(
				ctx, k8sClient,
				kdexv1alpha1.KDexInternalHost{
					ObjectMeta: metav1.ObjectMeta{
						Name:      focalHost,
						Namespace: namespace,
					},
					Spec: kdexv1alpha1.KDexInternalHostSpec{
						KDexHostSpec: kdexv1alpha1.KDexHostSpec{
							BrandName:    "KDex Tech",
							ModulePolicy: kdexv1alpha1.LooseModulePolicy,
							Organization: "KDex Tech Inc.",
							Routing: kdexv1alpha1.Routing{
								Domains: []string{
									"kdex.dev",
								},
							},
						},
					},
				},
			)

			assertResourceReady(
				ctx, k8sClient, focalHost, namespace,
				&kdexv1alpha1.KDexInternalHost{}, true)

			faasAdaptor := &kdexv1alpha1.KDexClusterFaaSAdaptor{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "kdex-default-faas-adaptor-knative",
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFaaSAdaptorSpec{
					Provider: "knative",
					Generators: map[string]kdexv1alpha1.GeneratorConfig{
						"go/go-env": {
							Image: "ghcr.io/kdex-dev/kdex-function-generator-go:latest",
						},
					},
				},
			}
			Expect(k8sClient.Create(ctx, faasAdaptor)).To(Succeed())

			Eventually(func(g Gomega) {
				fetched := &kdexv1alpha1.KDexFunction{}
				err := k8sClient.Get(ctx, client.ObjectKey{Name: resource.Name, Namespace: namespace}, fetched)
				g.Expect(err).NotTo(HaveOccurred())
				g.Expect(
					meta.IsStatusConditionFalse(
						fetched.Status.Conditions,
						string(kdexv1alpha1.ConditionTypeDegraded),
					),
				).To(BeTrue())
				g.Expect(
					meta.IsStatusConditionTrue(
						fetched.Status.Conditions,
						string(kdexv1alpha1.ConditionTypeProgressing),
					),
				).To(BeTrue())
				g.Expect(fetched.Status.State).To(Equal(kdexv1alpha1.KDexFunctionStateSourceAvailable))
			}, "10s", "1s").Should(Succeed())
		})

		It("becomes ExecutableAvailable", func() {
			resource := &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      resourceName,
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					HostRef: corev1.LocalObjectReference{Name: focalHost},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
					API: kdexv1alpha1.API{
						BasePath: "/v1/api",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/api/test": {},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Environment: "go-env",
						Language:    "go",
						Executable:  "foo",
					},
				},
			}

			Expect(k8sClient.Create(ctx, resource)).To(Succeed())

			addOrUpdateInternalHost(
				ctx, k8sClient,
				kdexv1alpha1.KDexInternalHost{
					ObjectMeta: metav1.ObjectMeta{
						Name:      focalHost,
						Namespace: namespace,
					},
					Spec: kdexv1alpha1.KDexInternalHostSpec{
						KDexHostSpec: kdexv1alpha1.KDexHostSpec{
							BrandName:    "KDex Tech",
							ModulePolicy: kdexv1alpha1.LooseModulePolicy,
							Organization: "KDex Tech Inc.",
							Routing: kdexv1alpha1.Routing{
								Domains: []string{
									"kdex.dev",
								},
							},
						},
					},
				},
			)

			assertResourceReady(
				ctx, k8sClient, focalHost, namespace,
				&kdexv1alpha1.KDexInternalHost{}, true)

			faasAdaptor := &kdexv1alpha1.KDexClusterFaaSAdaptor{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "kdex-default-faas-adaptor-knative",
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFaaSAdaptorSpec{
					Provider: "knative",
					Generators: map[string]kdexv1alpha1.GeneratorConfig{
						"go/go-env": {
							Image: "ghcr.io/kdex-dev/kdex-function-generator-go:latest",
						},
					},
				},
			}
			Expect(k8sClient.Create(ctx, faasAdaptor)).To(Succeed())

			Eventually(func(g Gomega) {
				fetched := &kdexv1alpha1.KDexFunction{}
				err := k8sClient.Get(ctx, client.ObjectKey{Name: resource.Name, Namespace: namespace}, fetched)
				g.Expect(err).NotTo(HaveOccurred())
				g.Expect(fetched.Status.State).To(Equal(kdexv1alpha1.KDexFunctionStateExecutableAvailable))
			}, "10s", "1s").Should(Succeed())
		})

		It("becomes FunctionDeployed", func() {
			Skip("Not ready yet")

			resource := &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      resourceName,
					Namespace: namespace,
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					HostRef: corev1.LocalObjectReference{Name: focalHost},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
					API: kdexv1alpha1.API{
						BasePath: "/v1/api",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/api/test": {},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Environment: "go-env",
						Language:    "go",
						Executable:  "foo",
					},
				},
			}

			Expect(k8sClient.Create(ctx, resource)).To(Succeed())

			addOrUpdateInternalHost(
				ctx, k8sClient,
				kdexv1alpha1.KDexInternalHost{
					ObjectMeta: metav1.ObjectMeta{
						Name:      focalHost,
						Namespace: namespace,
					},
					Spec: kdexv1alpha1.KDexInternalHostSpec{
						KDexHostSpec: kdexv1alpha1.KDexHostSpec{
							BrandName:    "KDex Tech",
							ModulePolicy: kdexv1alpha1.LooseModulePolicy,
							Organization: "KDex Tech Inc.",
							Routing: kdexv1alpha1.Routing{
								Domains: []string{
									"kdex.dev",
								},
							},
						},
					},
				},
			)

			assertResourceReady(
				ctx, k8sClient, focalHost, namespace,
				&kdexv1alpha1.KDexInternalHost{}, true)

			patch := client.MergeFrom(resource.DeepCopy())
			resource.Status.URL = "https://foo.bar"
			resource.Status.ObservedGeneration = resource.Generation
			Expect(k8sClient.Status().Patch(ctx, resource, patch)).To(Succeed())

			Eventually(func(g Gomega) {
				fetched := &kdexv1alpha1.KDexFunction{}
				err := k8sClient.Get(ctx, client.ObjectKey{Name: resource.Name, Namespace: namespace}, fetched)
				g.Expect(err).NotTo(HaveOccurred())
				g.Expect(fetched.Status.State).To(Equal(kdexv1alpha1.KDexFunctionStateFunctionDeployed))
				g.Expect(
					meta.IsStatusConditionFalse(
						fetched.Status.Conditions,
						string(kdexv1alpha1.ConditionTypeDegraded),
					),
				).To(BeTrue())
				g.Expect(
					meta.IsStatusConditionFalse(
						fetched.Status.Conditions,
						string(kdexv1alpha1.ConditionTypeProgressing),
					),
				).To(BeTrue())
				g.Expect(
					meta.IsStatusConditionTrue(
						fetched.Status.Conditions,
						string(kdexv1alpha1.ConditionTypeReady),
					),
				).To(BeTrue())
				cond := meta.FindStatusCondition(
					fetched.Status.Conditions,
					string(kdexv1alpha1.ConditionTypeProgressing),
				)
				g.Expect(cond.Message).To(Equal("Reconciliation successful"))
			}, "10s", "1s").Should(Succeed())
		})
	})
})
