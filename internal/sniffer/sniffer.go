package sniffer

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"

	openapi "github.com/getkin/kin-openapi/openapi3"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kdexv1alpha1 "kdex.dev/crds/api/v1alpha1"
	"kdex.dev/web/internal"
	"kdex.dev/web/internal/host"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

type RequestSniffer struct {
	Client      client.Client
	HostHandler *host.HostHandler
	HostName    string
	Namespace   string
}

func (s *RequestSniffer) DocsHandler(w http.ResponseWriter, r *http.Request) {
	docs := `
# KDex Request Sniffer Documentation

The KDex Request Sniffer automatically generates or updates KDexFunction resources by observing unhandled requests (404s).

## Supported Signals

### Custom HTTP Headers

- **X-KDex-Function-Name**: Specifies the name for the generated KDexFunction CR (standard Kubernetes naming rules apply).
- **X-KDex-Function-Pattern-Path**: Specifies a net/http pattern path (e.g., "/users/{id}"). 
  - Must start with "/"
  - Must NOT contain a method (e.g. use "/users/{id}" not "GET /users/{id}")
  - Variables are supported: "{name}", "{path...}"
- **X-KDex-Function-Description**: Sets the OpenAPI operation description.
- **X-KDex-Function-Summary**: Sets the OpenAPI operation summary.
- **X-KDex-Function-Tags**: Comma-separated list of tags for the OpenAPI operation.
- **X-KDex-Function-Operation-ID**: Sets a specific operationId in OpenAPI.
- **X-KDex-Function-Deprecated**: Set to "true" to mark the operation as deprecated.

### Core Header Introspection

- **Authorization**: If present, the sniffer signals that the route requires authentication. It adds security requirements matching the host's available modes (e.g., "bearer") and injects a "401 Unauthorized" response.
- **Accept**: If present and specific (not "*/*"), media types are used to populate the expected response "content" types in OpenAPI.
- **Content-Type**:
  - "application/json": The sniffer peeks at the body and infers a basic schema (types: string, number, boolean, object, array).
  - "application/x-www-form-urlencoded": The sniffer parses form fields and adds them as properties in the request body schema.

### Query Parameters

- Multi-value parameters (e.g., "?id=1&id=2") are detected and documented as "array" types in OpenAPI with "Explode: true".

---
*Note: The sniffer only processes non-internal paths (paths not starting with "/~") that result in a 404.*
`
	w.Header().Set("Content-Type", "text/markdown")
	_, _ = w.Write([]byte(docs))
}

// Basic criteria: non-HTML GET/POST requests that are not found
// (This is called when HostHandler hits a 404)
func (s *RequestSniffer) Sniff(r *http.Request) error {
	// Skip internal paths
	if strings.HasPrefix(r.URL.Path, "/~") {
		return nil
	}

	method := strings.ToUpper(r.Method)

	path, err := s.calculatePath(r, r.Header.Get("X-KDex-Function-Pattern-Path"))
	if err != nil {
		return err
	}

	// Check if a KDexFunction already exists for this path/method to avoid duplicates
	var functions kdexv1alpha1.KDexFunctionList
	if err := s.Client.List(context.Background(), &functions, client.InNamespace(s.Namespace), client.MatchingFields{internal.HOST_INDEX_KEY: s.HostName}); err != nil {
		return err
	}

	existing, exactMatch := s.matchExisting(functions.Items, path, method)
	if exactMatch && existing != nil && !existing.Spec.Metadata.AutoGenerated {
		// Exact match and it's manual. Skip.
		return nil
	}

	if existing != nil && !existing.Spec.Metadata.AutoGenerated {
		return fmt.Errorf("the function %s/%s can no longer be targeted for autogeneration: .spec.metadata.autoGenerated=false", existing.Name, existing.Namespace)
	}

	name := s.generateName(path, existing, r.Header.Get("X-KDex-Function-Name"))

	// Create a new KDexFunction

	api := s.parseRequestIntoAPI(r, method, path)

	fn := &kdexv1alpha1.KDexFunction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: s.Namespace,
		},
	}

	op, err := ctrl.CreateOrUpdate(
		context.Background(),
		s.Client,
		fn,
		func() error {
			s.mergeFunction(fn, api, path, existing)
			return nil
		},
	)

	log := logf.FromContext(r.Context())

	log.V(2).Info(
		"sniffed function",
		"fn", fn,
		"op", op,
		"err", err,
	)

	return err
}

func (s *RequestSniffer) calculatePath(r *http.Request, patternPath string) (string, error) {
	if patternPath == "" {
		return r.URL.Path, nil
	}

	if strings.Contains(patternPath, " ") {
		return "", fmt.Errorf("pattern path must not contain a method: %q", patternPath)
	}
	if !strings.HasPrefix(patternPath, "/") {
		return "", fmt.Errorf("pattern path must start with '/': %q", patternPath)
	}

	// Validate the path against the pattern path to make sure they align
	// The pattern path must follow the net/http pattern rules
	if err := s.validatePattern(patternPath, r); err != nil {
		return "", err
	}

	return patternPath, nil
}

func (s *RequestSniffer) generateName(path string, existing *kdexv1alpha1.KDexFunction, headerName string) string {
	if existing != nil {
		return existing.Name
	}
	if headerName != "" {
		return headerName
	}

	cleanPath := strings.NewReplacer("{", "", "}", "", ".", "-", "$", "", " ", "-", "[", "", "]", "").Replace(path)
	name := strings.ToLower(cleanPath)
	name = strings.ReplaceAll(name, "/", "-")

	// Collapse multiple dashes and trim
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '-'
	})
	name = strings.Join(parts, "-")

	if name == "" {
		return "gen-root"
	}
	return "gen-" + name
}

func (s *RequestSniffer) matchExisting(items []kdexv1alpha1.KDexFunction, path, method string) (existing *kdexv1alpha1.KDexFunction, exactMethodMatch bool) {
	for i := range items {
		fn := &items[i]
		if fn.Spec.API.Path != path {
			continue
		}

		methodMatch := (fn.Spec.API.Connect != nil && method == "CONNECT") ||
			(fn.Spec.API.Delete != nil && method == "DELETE") ||
			(fn.Spec.API.Get != nil && method == "GET") ||
			(fn.Spec.API.Head != nil && method == "HEAD") ||
			(fn.Spec.API.Options != nil && method == "OPTIONS") ||
			(fn.Spec.API.Patch != nil && method == "PATCH") ||
			(fn.Spec.API.Post != nil && method == "POST") ||
			(fn.Spec.API.Put != nil && method == "PUT") ||
			(fn.Spec.API.Trace != nil && method == "TRACE")

		if methodMatch {
			return fn, true
		}

		// Same path but different method.
		if fn.Spec.Metadata.AutoGenerated {
			existing = fn
		}
	}
	return existing, false
}

func (s *RequestSniffer) mergeFunction(fn *kdexv1alpha1.KDexFunction, api kdexv1alpha1.KDexOpenAPIInternal, path string, existing *kdexv1alpha1.KDexFunction) {
	if fn.CreationTimestamp.IsZero() {
		fn.Annotations = make(map[string]string)
		fn.Labels = make(map[string]string)

		fn.Labels["app.kubernetes.io/name"] = "kdex-web"
		fn.Labels["kdex.dev/instance"] = s.HostName

		fn.Spec = kdexv1alpha1.KDexFunctionSpec{}

		if existing != nil {
			fn.Spec = existing.Spec
		}

		fn.Spec.HostRef = v1.LocalObjectReference{
			Name: s.HostName,
		}
	}

	fn.Spec.Metadata.AutoGenerated = true
	if fn.Spec.API.Path == "" {
		fn.Spec.API.Path = path
	}
	if fn.Spec.API.Description == "" || strings.HasPrefix(fn.Spec.API.Description, "Auto-generated") {
		fn.Spec.API.Description = fmt.Sprintf("Auto-generated from request to %s", path)
	}

	// Merge operations
	if api.Connect != nil {
		fn.Spec.API.Connect = api.Connect
	}
	if api.Delete != nil {
		fn.Spec.API.Delete = api.Delete
	}
	if api.Get != nil {
		fn.Spec.API.Get = api.Get
	}
	if api.Head != nil {
		fn.Spec.API.Head = api.Head
	}
	if api.Options != nil {
		fn.Spec.API.Options = api.Options
	}
	if api.Patch != nil {
		fn.Spec.API.Patch = api.Patch
	}
	if api.Post != nil {
		fn.Spec.API.Post = api.Post
	}
	if api.Put != nil {
		fn.Spec.API.Put = api.Put
	}
	if api.Trace != nil {
		fn.Spec.API.Trace = api.Trace
	}

	// Merge parameters by name and 'in'
	for _, newParam := range api.Parameters {
		exists := false
		for j, existingParam := range fn.Spec.API.Parameters {
			if existingParam.Name == newParam.Name && existingParam.In == newParam.In {
				fn.Spec.API.Parameters[j] = newParam
				exists = true
				break
			}
		}
		if !exists {
			fn.Spec.API.Parameters = append(fn.Spec.API.Parameters, newParam)
		}
	}

	// Merge schemas
	if len(api.Schemas) > 0 {
		if fn.Spec.API.Schemas == nil {
			fn.Spec.API.Schemas = make(map[string]openapi.Schema)
		}
		for k, v := range api.Schemas {
			fn.Spec.API.Schemas[k] = v
		}
	}

	if fn.Spec.Function.Language == "" {
		fn.Spec.Function.Language = "go"
	}
	if fn.Spec.Function.Environment == "" {
		fn.Spec.Function.Environment = "go-env"
	}
}

func (s *RequestSniffer) parseRequestIntoAPI(r *http.Request, method string, patternPath string) kdexv1alpha1.KDexOpenAPIInternal {
	api := kdexv1alpha1.KDexOpenAPIInternal{}

	op := &openapi.Operation{
		Responses: openapi.NewResponses(),
	}

	// Default response
	resp := openapi.NewResponse().WithDescription("Successful response")
	accept := r.Header.Get("Accept")
	if accept != "" {
		content := openapi.NewContent()
		// Split by comma and handle types like application/json;q=0.9
		types := strings.Split(accept, ",")
		for _, t := range types {
			mediaType := strings.TrimSpace(strings.Split(t, ";")[0])
			if mediaType == "" || mediaType == "*/*" {
				continue
			}
			content[mediaType] = &openapi.MediaType{
				Schema: &openapi.SchemaRef{
					Value: openapi.NewSchema(),
				},
			}
		}
		if len(content) > 0 {
			resp.Content = content
		}
	}

	op.Responses.Set("default", &openapi.ResponseRef{
		Value: resp,
	})

	// Metadata from headers
	if tagsRaw := r.Header.Get("X-KDex-Function-Tags"); tagsRaw != "" {
		op.Tags = strings.Split(tagsRaw, ",")
		for i := range op.Tags {
			op.Tags[i] = strings.TrimSpace(op.Tags[i])
		}
	}

	op.Summary = r.Header.Get("X-KDex-Function-Summary")
	if op.Summary == "" && r.Header.Get("X-KDex-Function-Name") != "" {
		op.Summary = r.Header.Get("X-KDex-Function-Name")
	}

	op.Description = r.Header.Get("X-KDex-Function-Description")
	if op.Description == "" {
		op.Description = fmt.Sprintf("Auto-generated from request to %s", r.URL.Path)
	}

	op.OperationID = r.Header.Get("X-KDex-Function-Operation-ID")
	op.Deprecated = strings.ToLower(r.Header.Get("X-KDex-Function-Deprecated")) == "true"

	// Authentication signal
	if r.Header.Get("Authorization") != "" {
		modes := s.HostHandler.SecurityModes()
		if len(modes) > 0 {
			security := openapi.SecurityRequirements{}
			for _, mode := range modes {
				security = append(security, openapi.SecurityRequirement{
					mode: []string{},
				})
			}
			op.Security = &security

			// Add 401 response when auth is required
			op.Responses.Set("401", &openapi.ResponseRef{
				Value: openapi.NewResponse().WithDescription("Unauthorized - Authentication required"),
			})
		}
	}

	// Parameters
	params := []openapi.Parameter{}

	// 1. Path Parameters from patternPath
	if patternPath != "" {
		re := regexp.MustCompile(`\{([^}]+)\}`)
		matches := re.FindAllStringSubmatch(patternPath, -1)
		for _, m := range matches {
			name := strings.TrimSuffix(m[1], "...")
			params = append(params, openapi.Parameter{
				Name:     name,
				In:       "path",
				Required: true,
				Schema: &openapi.SchemaRef{
					Value: openapi.NewStringSchema(),
				},
			})
		}
	}

	// 2. Query Parameters
	for name, values := range r.URL.Query() {
		param := openapi.Parameter{
			Name: name,
			In:   "query",
		}

		schema := openapi.NewStringSchema()
		if len(values) > 1 {
			// It's likely an array
			param.Explode = openapi.Ptr(true)
			param.Style = "form"
			schema = openapi.NewArraySchema()
			schema.Items = &openapi.SchemaRef{
				Value: openapi.NewStringSchema(),
			}
		}

		param.Schema = &openapi.SchemaRef{
			Value: schema,
		}
		params = append(params, param)
	}

	// 3. Header Parameters (Selective)
	skipHeaders := map[string]bool{
		"accept":                    true,
		"accept-encoding":           true,
		"accept-language":           true,
		"authorization":             true,
		"connection":                true,
		"content-length":            true,
		"content-type":              true,
		"cookie":                    true,
		"expect":                    true,
		"host":                      true,
		"if-match":                  true,
		"if-none-match":             true,
		"if-modified-since":         true,
		"if-unmodified-since":       true,
		"origin":                    true,
		"priority":                  true,
		"referer":                   true,
		"sec-ch-ua":                 true,
		"sec-ch-ua-mobile":          true,
		"sec-ch-ua-platform":        true,
		"sec-fetch-dest":            true,
		"sec-fetch-mode":            true,
		"sec-fetch-site":            true,
		"sec-fetch-user":            true,
		"upgrade-insecure-requests": true,
		"user-agent":                true,
		"x-forwarded-for":           true,
		"x-forwarded-host":          true,
		"x-forwarded-proto":         true,
		"x-real-ip":                 true,
	}

	for name := range r.Header {
		lowerName := strings.ToLower(name)
		if strings.HasPrefix(lowerName, "x-kdex-") || skipHeaders[lowerName] {
			continue
		}
		params = append(params, openapi.Parameter{
			Name: name,
			In:   "header",
			Schema: &openapi.SchemaRef{
				Value: openapi.NewStringSchema(),
			},
		})
	}

	api.Parameters = params

	// 4. Request Body
	if r.ContentLength > 0 || r.Header.Get("Content-Type") != "" {
		contentType := strings.Split(r.Header.Get("Content-Type"), ";")[0]
		if contentType == "" {
			contentType = "application/octet-stream"
		}

		schema := openapi.NewSchema()

		// If it's form data, try to be specific about properties
		if contentType == "application/x-www-form-urlencoded" {
			_ = r.ParseForm()
			schema.Type = &openapi.Types{"object"}
			schema.Properties = make(openapi.Schemas)
			for name := range r.PostForm {
				schema.Properties[name] = &openapi.SchemaRef{
					Value: openapi.NewStringSchema(),
				}
			}
		} else if contentType == "application/json" {
			// Try to peek at the JSON to infer a basic schema
			body, err := io.ReadAll(r.Body)
			if err == nil {
				// Restore body for any subsequent users (though unlikely in 404 path)
				r.Body = io.NopCloser(strings.NewReader(string(body)))

				var data any
				if err := json.Unmarshal(body, &data); err == nil {
					if obj, ok := data.(map[string]any); ok {
						schema.Type = &openapi.Types{"object"}
						schema.Properties = make(openapi.Schemas)
						for k, v := range obj {
							propSchema := openapi.NewSchema()
							switch v.(type) {
							case string:
								propSchema.Type = &openapi.Types{"string"}
							case float64:
								propSchema.Type = &openapi.Types{"number"}
							case bool:
								propSchema.Type = &openapi.Types{"boolean"}
							case map[string]any:
								propSchema.Type = &openapi.Types{"object"}
							case []any:
								propSchema.Type = &openapi.Types{"array"}
							}
							schema.Properties[k] = &openapi.SchemaRef{
								Value: propSchema,
							}
						}
					}
				}
			}
		}

		op.RequestBody = &openapi.RequestBodyRef{
			Value: &openapi.RequestBody{
				Content: openapi.NewContent(),
			},
		}

		op.RequestBody.Value.Content[contentType] = &openapi.MediaType{
			Schema: &openapi.SchemaRef{
				Value: schema,
			},
		}
	}

	// Assign operation to method
	switch method {
	case "CONNECT":
		api.Connect = op
	case "DELETE":
		api.Delete = op
	case "GET":
		api.Get = op
	case "HEAD":
		api.Head = op
	case "OPTIONS":
		api.Options = op
	case "PATCH":
		api.Patch = op
	case "POST":
		api.Post = op
	case "PUT":
		api.Put = op
	case "TRACE":
		api.Trace = op
	}

	return api
}

func (s *RequestSniffer) validatePattern(pattern string, r *http.Request) (err error) {
	// http.NewServeMux().HandleFunc panics if the pattern is invalid.
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("invalid pattern path %q: %v", pattern, r)
		}
	}()

	mux := http.NewServeMux()
	mux.HandleFunc(pattern, func(w http.ResponseWriter, r *http.Request) {})
	_, matched := mux.Handler(r)
	if matched == "" {
		return fmt.Errorf("request %s %s does not align with pattern path %q", r.Method, r.URL.Path, pattern)
	}

	return nil
}
