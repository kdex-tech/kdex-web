package sniffer

import (
	"bytes"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"net/textproto"
	"net/url"
	"strings"
	"testing"

	openapi "github.com/getkin/kin-openapi/openapi3"
	"github.com/stretchr/testify/assert"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	kdexv1alpha1 "kdex.dev/crds/api/v1alpha1"
	ko "kdex.dev/web/internal/openapi"
)

func TestRequestSniffer_analyze(t *testing.T) {
	s := RequestSniffer{
		BasePathRegex: (&kdexv1alpha1.API{}).BasePathRegex(),
		HostName:      "test-host",
		ItemPathRegex: (&kdexv1alpha1.API{}).ItemPathRegex(),
	}

	tests := []struct {
		name       string
		r          *http.Request
		assertions func(t *testing.T, res *AnalysisResult, err error)
	}{
		{
			name: "GET /v1/foo",
			r: func() *http.Request {
				return httptest.NewRequest("GET", "/v1/foo", http.NoBody)
			}(),
			assertions: func(t *testing.T, res *AnalysisResult, err error) {
				assert.NoError(t, err)
				//assert.Equal(t, 0, len(res.Lints))
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, gotErr := s.analyze(tt.r)
			tt.assertions(t, got, gotErr)
		})
	}
}

func TestRequestSniffer_calculatePath(t *testing.T) {
	tests := []struct {
		name            string
		method          string
		requestPath     string
		patternPath     string
		wantBasePath    string
		wantPatternPath string
		wantErr         bool
	}{
		{
			name:            "get simple path",
			method:          "GET",
			requestPath:     "/v1/pies",
			wantBasePath:    "/v1/pies",
			wantPatternPath: "/v1/pies",
		},
		{
			name:            "get with pattern match",
			method:          "GET",
			requestPath:     "/v1/pies/1",
			patternPath:     "/v1/pies/{id}",
			wantBasePath:    "/v1/pies",
			wantPatternPath: "/v1/pies/{id}",
		},
		{
			name:        "get with pattern mismatch path",
			method:      "GET",
			requestPath: "/v1/pies/1",
			patternPath: "/users/{id}",
			wantErr:     true,
		},
		{
			name:            "get with wildcard pattern",
			method:          "GET",
			requestPath:     "/v1/static/css/main.css",
			patternPath:     "/v1/static/{path...}",
			wantBasePath:    "/v1/static",
			wantPatternPath: "/v1/static/{path...}",
		},
		{
			name:        "error: pattern with method",
			method:      "GET",
			requestPath: "/v1/users/123",
			patternPath: "GET /users/{id}",
			wantErr:     true,
		},
		{
			name:        "error: pattern without leading slash",
			method:      "GET",
			requestPath: "/v1/users/123",
			patternPath: "v1/users/{id}",
			wantErr:     true,
		},
		{
			name:        "invalid pattern format",
			method:      "GET",
			requestPath: "/v1/users",
			patternPath: "/v1/users/{",
			wantErr:     true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := RequestSniffer{
				BasePathRegex: (&kdexv1alpha1.API{}).BasePathRegex(),
				HostName:      "test-host",
				ItemPathRegex: (&kdexv1alpha1.API{}).ItemPathRegex(),
			}
			r := httptest.NewRequest(tt.method, tt.requestPath, &io.PipeReader{})
			gotBasePath, gotPatternPath, gotErr := s.calculatePaths(r, tt.patternPath)
			if tt.wantErr {
				assert.Error(t, gotErr)
				return
			}
			assert.NoError(t, gotErr)
			assert.Equal(t, tt.wantBasePath, gotBasePath)
			assert.Equal(t, tt.wantPatternPath, gotPatternPath)
		})
	}
}

func TestRequestSniffer_matchExisting(t *testing.T) {
	items := []kdexv1alpha1.KDexFunction{
		{
			ObjectMeta: metav1.ObjectMeta{Name: "gen-users"},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				API: kdexv1alpha1.API{
					BasePath: "/users",
					Paths: map[string]kdexv1alpha1.PathItem{
						"/users": {
							Get: raw(&openapi.Operation{
								OperationID: "gen-users-get",
							}),
						},
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{AutoGenerated: true},
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{Name: "gen-posts"},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				API: kdexv1alpha1.API{
					BasePath: "/posts",
					Paths: map[string]kdexv1alpha1.PathItem{
						"/posts": {
							Post: raw(&openapi.Operation{
								OperationID: "gen-posts-post",
							}),
						},
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{AutoGenerated: false},
			},
		},
	}

	tests := []struct {
		name                 string
		headerFunctionName   string
		headerOperationId    string
		basePath             string
		routePath            string
		method               string
		wantExistingName     string
		wantExactMethodMatch bool
	}{
		{
			name:                 "exact match autogenerated",
			basePath:             "/users",
			routePath:            "/users",
			method:               "GET",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: true,
		},
		{
			name:                 "exact match manual",
			basePath:             "/posts",
			routePath:            "/posts",
			method:               "POST",
			wantExistingName:     "gen-posts",
			wantExactMethodMatch: true,
		},
		{
			name:                 "path match but new method",
			basePath:             "/users",
			routePath:            "/users",
			method:               "POST",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: false,
		},
		{
			name:                 "no match",
			basePath:             "/unknown",
			routePath:            "/unknown",
			method:               "GET",
			wantExistingName:     "",
			wantExactMethodMatch: false,
		},
		{
			name:                 "match by name header",
			basePath:             "/users",
			routePath:            "/users",
			method:               "GET",
			headerFunctionName:   "gen-users",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: true,
		},
		{
			name:                 "match by operation id header",
			basePath:             "/users",
			routePath:            "/users",
			method:               "GET",
			headerFunctionName:   "foo",
			headerOperationId:    "gen-users-get",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			name := ko.GenerateNameFromPath(tt.routePath, tt.headerFunctionName)
			operationId := ko.GenerateOperationID(name, tt.method, tt.headerOperationId)

			s := &RequestSniffer{
				HostName: "test-host",
			}
			gotExisting, gotExact := s.matchExisting(items, name, tt.basePath, tt.routePath, tt.method, operationId)
			if tt.wantExistingName == "" {
				assert.Nil(t, gotExisting)
			} else {
				assert.NotNil(t, gotExisting)
				assert.Equal(t, tt.wantExistingName, gotExisting.Name)
			}
			assert.Equal(t, tt.wantExactMethodMatch, gotExact)
		})
	}
}

func TestRequestSniffer_op_inMatchesOut(t *testing.T) {
	tests := []struct {
		name       string
		in         any
		assertions func(t *testing.T, pi *kdexv1alpha1.PathItem, in any)
	}{
		{
			name: "operation equals through serialization",
			in: &openapi.Operation{
				Description: "Test",
			},
			assertions: func(t *testing.T, pi *kdexv1alpha1.PathItem, in any) {
				pi.SetConnect(in.(*openapi.Operation))
				assert.Equal(t, in, pi.GetConnect())
				assert.Contains(t, string(pi.Connect.Raw), `"Test"`)
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pi := &kdexv1alpha1.PathItem{}
			tt.assertions(t, pi, tt.in)
		})
	}
}

func TestRequestSniffer_schema_inMatchesOut(t *testing.T) {
	tests := []struct {
		name       string
		in         any
		assertions func(t *testing.T, kdo *kdexv1alpha1.API, in any)
	}{
		{
			name: "schemas equals through serialization",
			in: map[string]*openapi.SchemaRef{
				"User": {
					Value: &openapi.Schema{
						Type: &openapi.Types{openapi.TypeString},
					},
				},
			},
			assertions: func(t *testing.T, kdo *kdexv1alpha1.API, in any) {
				kdo.SetSchemas(in.(map[string]*openapi.SchemaRef))
				assert.Equal(t, in, kdo.GetSchemas())

				v, ok := kdo.Schemas["User"]
				assert.True(t, ok)
				assert.Contains(t, string(v.Raw), `"string"`)
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			kdo := &kdexv1alpha1.API{}
			tt.assertions(t, kdo, tt.in)
		})
	}
}

func TestRequestSniffer_mergeAPIIntoFunction(t *testing.T) {
	s := &RequestSniffer{
		HostName: "test-host",
	}

	tests := []struct {
		name          string
		out           *kdexv1alpha1.KDexFunction
		paths         map[string]*openapi.PathItem
		schemas       map[string]*openapi.SchemaRef
		keepConflicts bool
		assertions    func(t *testing.T, fn *kdexv1alpha1.KDexFunction)
	}{
		{
			name:       "no op",
			out:        &kdexv1alpha1.KDexFunction{},
			paths:      map[string]*openapi.PathItem{},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {},
		},
		{
			name: "add connect",
			out:  &kdexv1alpha1.KDexFunction{},
			paths: map[string]*openapi.PathItem{
				"/path": {
					Connect: &openapi.Operation{
						Description: "CONNECT /path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				item, ok := fn.Spec.API.Paths["/path"]
				assert.True(t, ok)
				assert.Contains(t, "CONNECT /path", item.GetConnect().Description)
			},
		},
		{
			name: "add delete",
			out:  &kdexv1alpha1.KDexFunction{},
			paths: map[string]*openapi.PathItem{
				"/path": {
					Delete: &openapi.Operation{
						Description: "DELETE /path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				item, ok := fn.Spec.API.Paths["/path"]
				assert.True(t, ok)
				assert.Contains(t, "DELETE /path", item.GetDelete().Description)
			},
		},
		{
			name: "add head",
			out:  &kdexv1alpha1.KDexFunction{},
			paths: map[string]*openapi.PathItem{
				"/path": {
					Head: &openapi.Operation{
						Description: "HEAD /path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				item, ok := fn.Spec.API.Paths["/path"]
				assert.True(t, ok)
				assert.Contains(t, "HEAD /path", item.GetHead().Description)
			},
		},
		{
			name: "add options",
			out:  &kdexv1alpha1.KDexFunction{},
			paths: map[string]*openapi.PathItem{
				"/path": {
					Options: &openapi.Operation{
						Description: "OPTIONS /path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				item, ok := fn.Spec.API.Paths["/path"]
				assert.True(t, ok)
				assert.Contains(t, "OPTIONS /path", item.GetOptions().Description)
			},
		},
		{
			name: "add patch",
			out:  &kdexv1alpha1.KDexFunction{},
			paths: map[string]*openapi.PathItem{
				"/path": {
					Patch: &openapi.Operation{
						Description: "PATCH /path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				item, ok := fn.Spec.API.Paths["/path"]
				assert.True(t, ok)
				assert.Contains(t, "PATCH /path", item.GetPatch().Description)
			},
		},
		{
			name: "add post",
			out:  &kdexv1alpha1.KDexFunction{},
			paths: map[string]*openapi.PathItem{
				"/path": {
					Post: &openapi.Operation{
						Description: "POST /path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				item, ok := fn.Spec.API.Paths["/path"]
				assert.True(t, ok)
				assert.Contains(t, "POST /path", item.GetPost().Description)
			},
		},
		{
			name: "add put",
			out:  &kdexv1alpha1.KDexFunction{},
			paths: map[string]*openapi.PathItem{
				"/path": {
					Put: &openapi.Operation{
						Description: "PUT /path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				item, ok := fn.Spec.API.Paths["/path"]
				assert.True(t, ok)
				assert.Contains(t, "PUT /path", item.GetPut().Description)
			},
		},
		{
			name: "add trace",
			out:  &kdexv1alpha1.KDexFunction{},
			paths: map[string]*openapi.PathItem{
				"/path": {
					Trace: &openapi.Operation{
						Description: "TRACE /path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				item, ok := fn.Spec.API.Paths["/path"]
				assert.True(t, ok)
				assert.Contains(t, "TRACE /path", item.GetTrace().Description)
			},
		},
		{
			name: "set path",
			out:  &kdexv1alpha1.KDexFunction{},
			paths: map[string]*openapi.PathItem{
				"/foo": {},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				_, ok := fn.Spec.API.Paths["/foo"]
				assert.True(t, ok)
			},
		},
		{
			name:  "add new schema",
			out:   &kdexv1alpha1.KDexFunction{},
			paths: map[string]*openapi.PathItem{},
			schemas: map[string]*openapi.SchemaRef{
				"User": {
					Value: &openapi.Schema{
						Type: &openapi.Types{openapi.TypeObject},
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				schemas := fn.Spec.API.GetSchemas()

				s, ok := schemas["User"]
				assert.Equal(t, true, ok)
				assert.Equal(t, &openapi.Types{openapi.TypeObject}, s.Value.Type)
			},
		},
		{
			name: "add conflicting schema",
			out: &kdexv1alpha1.KDexFunction{
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.API{
						Schemas: rawM(map[string]*openapi.SchemaRef{
							"User": {
								Value: &openapi.Schema{
									Description: "Existing User",
									Type:        &openapi.Types{openapi.TypeObject},
								},
							},
						}),
					},
				},
			},
			schemas: map[string]*openapi.SchemaRef{
				"User": {
					Value: &openapi.Schema{
						Description: "Conflicting User",
						Type:        &openapi.Types{openapi.TypeObject},
					},
				},
			},
			keepConflicts: true,
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				schemas := fn.Spec.API.GetSchemas()

				s, ok := schemas["User"]
				assert.Equal(t, true, ok)
				assert.Equal(t, "Existing User", s.Value.Description)
				assert.Equal(t, 2, len(fn.Spec.API.Schemas))

				found := ""
				for key, schema := range schemas {
					if strings.HasPrefix(key, "User:conflict:") {
						found = schema.Value.Description
						break
					}
				}
				assert.Equal(t, "Conflicting User", found)
			},
		},
		{
			name: "add trace to existing",
			out: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name: "gen-path",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.API{
						BasePath: "/path",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/path": {
								Get: raw(&openapi.Operation{
									Description: "GET /path",
								}),
							},
						},
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
				},
			},
			paths: map[string]*openapi.PathItem{
				"/path": {
					Trace: &openapi.Operation{
						Description: "TRACE /path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				item, ok := fn.Spec.API.Paths["/path"]
				assert.True(t, ok)
				assert.Equal(t, "GET /path", item.GetGet().Description)
				assert.Equal(t, "TRACE /path", item.GetTrace().Description)
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// TODO: pass overwriteOperation bool and test it...
			s.mergeAPIIntoFunction(tt.out, tt.paths, tt.schemas, true, tt.keepConflicts)
			tt.assertions(t, tt.out)
		})
	}
}

func TestRequestSniffer_parseRequestIntoAPI(t *testing.T) {
	s := &RequestSniffer{
		HostName: "test-host",
		SecuritySchemes: &openapi.SecuritySchemes{
			"bearer": &openapi.SecuritySchemeRef{
				Value: openapi.NewJWTSecurityScheme(),
			},
		},
	}

	tests := []struct {
		name       string
		r          *http.Request
		assertions func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error)
		skip       bool
	}{
		{
			name: "GET /foo",
			r:    httptest.NewRequest("GET", "/foo", http.NoBody),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/foo"]
				assert.True(t, ok)
				assert.Equal(t, "gen-foo-get", item.Get.OperationID)
				assert.Nil(t, item.Get.Security)
			},
		},
		{
			name: "GET /foo with tags",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("X-KDex-Function-Tags", "one,two,three")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/foo"]
				assert.True(t, ok)
				assert.Equal(t, "gen-foo-get", item.Get.OperationID)
				assert.Equal(t, []string{"one", "two", "three", "test"}, item.Get.Tags)
			},
		},
		{
			name: "GET /foo with description and summary",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("X-KDex-Function-Description", "custom description")
				r.Header.Add("X-KDex-Function-Summary", "custom summary")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/foo"]
				assert.True(t, ok)
				assert.Equal(t, "gen-foo-get", item.Get.OperationID)
				assert.Equal(t, "custom description", item.Get.Description)
				assert.Equal(t, "custom summary", item.Get.Summary)
			},
		},
		{
			name: "GET /foo without Accept: produces default schemaless response",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/foo"]
				assert.True(t, ok)
				assert.Equal(t, "gen-foo-get", item.Get.OperationID)
				assert.Equal(t, 1, item.Get.Responses.Len())
				resp := item.Get.Responses.Value("200")
				assert.NotNil(t, resp)
				assert.Equal(t, openapi.Ptr("Successful response"), resp.Value.Description)
				assert.Equal(t, 0, len(resp.Value.Content))
			},
		},
		{
			name: "GET /foo with Accept: *\\* produces schemaless response",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("Accept", "*/*")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/foo"]
				assert.True(t, ok)
				assert.Equal(t, "gen-foo-get", item.Get.OperationID)
				assert.Equal(t, 1, item.Get.Responses.Len())
				resp := item.Get.Responses.Value("200")
				assert.NotNil(t, resp)
				assert.Equal(t, openapi.Ptr("Successful response"), resp.Value.Description)
				assert.Equal(t, 0, len(resp.Value.Content))
			},
		},
		{
			name: "GET /foo with specific Accept: produces schema response",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("Accept", "application/json")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/foo"]
				assert.True(t, ok)
				assert.Equal(t, "gen-foo-get", item.Get.OperationID)
				assert.Equal(t, 1, item.Get.Responses.Len())
				resp := item.Get.Responses.Value("200")
				assert.NotNil(t, resp)
				assert.Equal(t, openapi.Ptr("Successful response"), resp.Value.Description)
				assert.Equal(t, 1, len(resp.Value.Content))
				assert.Nil(t, resp.Value.Content.Get("application/json").Schema)
			},
		},
		{
			name: "GET /foo with specific Accept: and set X-KDex-Function-Response-Schema-Ref",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("Accept", "application/json")
				r.Header.Add("X-KDex-Function-Response-Schema-Ref", "Foo")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/foo"]
				assert.True(t, ok)
				assert.Equal(t, "gen-foo-get", item.Get.OperationID)
				assert.Equal(t, 1, item.Get.Responses.Len())
				resp := item.Get.Responses.Value("200")
				assert.NotNil(t, resp)
				assert.Equal(t, openapi.Ptr("Successful response"), resp.Value.Description)
				assert.Equal(t, 1, len(resp.Value.Content))
				assert.NotNil(t, resp.Value.Content.Get("application/json").Schema)
				assert.Equal(t, "#/components/schemas/Foo", resp.Value.Content.Get("application/json").Schema.Ref)
			},
		},
		{
			name: "detect auth",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Set("X-KDex-Function-Security", "bearer")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/foo"]
				assert.True(t, ok)
				assert.Equal(t, "gen-foo-get", item.Get.OperationID)
				assert.NotNil(t, item.Get.Security)
				assert.Len(t, *item.Get.Security, 1)
				assert.Contains(t, (*item.Get.Security)[0], "bearer")
			},
		},
		{
			name: "query array",
			r:    httptest.NewRequest("GET", "/test?id=1&id=2", http.NoBody),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.Equal(t, "gen-test-get", item.Get.OperationID)
				found := false
				for _, p := range item.Get.Parameters {
					if p.Value.Name == "id" {
						assert.True(t, p.Value.Schema.Value.Type.Is("array"))
						found = true
					}
				}
				assert.True(t, found)
			},
		},
		{
			name: "json schema inference",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", strings.NewReader(`
{
	"name": "John",
	"age": 30,
	"active": true,
	"tags": [
		"ai",
		"google"
	],
	"address": {
		"line1": "123 The Road",
		"Country": "BQ"
	}
}`))
				r.Header.Set("Content-Type", "application/json")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				expected := openapi.Schema{
					Description: "Inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"name": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"age": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeNumber},
							},
						},
						"active": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeBoolean},
							},
						},
						"tags": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
						"address": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeObject},
								Properties: openapi.Schemas{
									"line1": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
									"Country": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
								},
							},
						},
					},
				}

				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.NotNil(t, item.Post.RequestBody)
				content := item.Post.RequestBody.Value.Content["application/json"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect json schema and do inference",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", strings.NewReader(`
{
	"name": "John",
	"age": 30,
	"active": true,
	"tags": [
		"ai",
		"google"
	],
	"address": {
		"line1": "123 The Road",
		"Country": "BQ"
	}
}`))
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				expected := openapi.Schema{
					Description: "Inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"name": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"age": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeNumber},
							},
						},
						"active": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeBoolean},
							},
						},
						"tags": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
						"address": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeObject},
								Properties: openapi.Schemas{
									"line1": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
									"Country": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
								},
							},
						},
					},
				}

				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.NotNil(t, item.Post.RequestBody)
				content := item.Post.RequestBody.Value.Content["application/json"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect application\\octet-stream",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", bytes.NewReader([]byte{123, 23, 34, 145, 233}))
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				expected := openapi.Schema{
					Description: "Inferred from request body",
					Type:        &openapi.Types{openapi.TypeString},
					Format:      "binary",
				}

				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.NotNil(t, item.Post.RequestBody)
				content := item.Post.RequestBody.Value.Content["application/octet-stream"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect application\\x-www-form-urlencoded and schema",
			r: func() *http.Request {
				data := url.Values{}
				data.Set("name", "John Doe")
				data.Set("email", "john@example.com")
				data.Set("occupation", "Software Engineer")
				encodedData := data.Encode()
				r := httptest.NewRequest("POST", "/test", strings.NewReader(encodedData))
				r.Header.Set("Content-Type", "application/x-www-form-urlencoded")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				expected := openapi.Schema{
					Description: "Inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"name": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"email": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"occupation": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
					},
				}

				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.NotNil(t, item.Post.RequestBody)
				content := item.Post.RequestBody.Value.Content["application/x-www-form-urlencoded"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect mutlipart\\form-data and schema",
			r: func() *http.Request {
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)
				_ = writer.WriteField("username", "gopher_fan")
				_ = writer.WriteField("type", "admin")
				part, _ := writer.CreateFormFile("profile_pic", "image.svg")
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))
				writer.Close()
				r := httptest.NewRequest("POST", "/test", body)
				r.Header.Set("Content-Type", writer.FormDataContentType())
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				expectedSchema := openapi.Schema{
					Description: "Inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"username": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"type": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"profile_pic": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Format: "binary",
								Type:   &openapi.Types{openapi.TypeString},
							},
						},
					},
				}
				expectedEncoding := map[string]*openapi.Encoding{
					"profile_pic": {
						ContentType: "image/svg+xml",
					},
				}

				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.NotNil(t, item.Post.RequestBody)
				content := item.Post.RequestBody.Value.Content["multipart/form-data"]
				assert.NotNil(t, content)
				assert.Equal(t, &expectedSchema, content.Schema.Value)
				assert.Equal(t, expectedEncoding, content.Encoding)
			},
		},
		{
			name: "mutlipart\\form-data with content type and schema",
			r: func() *http.Request {
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)
				_ = writer.WriteField("username", "gopher_fan")
				h := make(textproto.MIMEHeader)
				h.Set("Content-Disposition", `form-data; name="profile_pic"; filename="image.svg"`)
				h.Set("Content-Type", "image/svg+xml")
				part, _ := writer.CreatePart(h)
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))
				writer.Close()
				r := httptest.NewRequest("POST", "/test", body)
				r.Header.Set("Content-Type", writer.FormDataContentType())
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				expectedSchema := openapi.Schema{
					Description: "Inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"username": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"profile_pic": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Format: "binary",
								Type:   &openapi.Types{openapi.TypeString},
							},
						},
					},
				}
				expectedEncoding := map[string]*openapi.Encoding{
					"profile_pic": {
						ContentType: "image/svg+xml",
					},
				}

				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.NotNil(t, item.Post.RequestBody)
				content := item.Post.RequestBody.Value.Content["multipart/form-data"]
				assert.NotNil(t, content)
				assert.Equal(t, &expectedSchema, content.Schema.Value)
				assert.Equal(t, expectedEncoding, content.Encoding)
			},
		},
		{
			name: "mutlipart\\form-data with content type, arrays schema",
			r: func() *http.Request {
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)
				_ = writer.WriteField("username", "gopher_fan")
				_ = writer.WriteField("username", "bear_dude")

				// array file 1
				h := make(textproto.MIMEHeader)
				h.Set("Content-Disposition", `form-data; name="profile_pic"; filename="one.svg"`)
				h.Set("Content-Type", "image/svg+xml")
				part, _ := writer.CreatePart(h)
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))

				// array file 2
				h = make(textproto.MIMEHeader)
				h.Set("Content-Disposition", `form-data; name="profile_pic"; filename="two.svg"`)
				h.Set("Content-Type", "image/svg+xml")
				part, _ = writer.CreatePart(h)
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))

				writer.Close()
				r := httptest.NewRequest("POST", "/test", body)
				r.Header.Set("Content-Type", writer.FormDataContentType())
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				expectedSchema := openapi.Schema{
					Description: "Inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"username": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
						"profile_pic": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type:   &openapi.Types{openapi.TypeString},
										Format: "binary",
									},
								},
							},
						},
					},
				}
				expectedEncoding := map[string]*openapi.Encoding{
					"profile_pic": {
						ContentType: "image/svg+xml",
					},
				}

				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.NotNil(t, item.Post.RequestBody)
				content := item.Post.RequestBody.Value.Content["multipart/form-data"]
				assert.NotNil(t, content)
				assert.Equal(t, &expectedSchema, content.Schema.Value)
				assert.Equal(t, expectedEncoding, content.Encoding)
			},
		},
		{
			name: "override response schema",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", strings.NewReader(`{}`))
				r.Header.Set("X-KDex-Function-Request-Schema-Ref", "Foo")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.NotNil(t, item.Post.RequestBody)
				content := item.Post.RequestBody.Value.Content["application/json"]
				assert.NotNil(t, content)
				assert.Equal(t, "#/components/schemas/Foo", content.Schema.Ref)
				sharedSchema := schemas["Foo"]
				assert.NotNil(t, sharedSchema)
			},
		},
		{
			name: "external request schema override",
			r: func() *http.Request {
				r := httptest.NewRequest("PATCH", "/test", strings.NewReader(`[{"op": "replace", "path": "/email", "value": "john@fix.buz"}]`))
				r.Header.Set("X-KDex-Function-Request-Schema-Ref", "https://json.schemastore.org/json-patch")
				r.Header.Set("Content-Type", "application/json-patch+json")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.NotNil(t, item.Patch.RequestBody)
				content := item.Patch.RequestBody.Value.Content["application/json-patch+json"]
				assert.NotNil(t, content)
				assert.Equal(t, "https://json.schemastore.org/json-patch", content.Schema.Ref)
				assert.Equal(t, 1, len(schemas))
			},
		},
		{
			name: "external response schema override",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/test", http.NoBody)
				r.Header.Set("X-KDex-Function-Response-Schema-Ref", "https://json.schemastore.org/json-patch")
				r.Header.Set("Accept", "application/json-patch+json")
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				resp := item.Get.Responses.Value("200")
				assert.NotNil(t, resp)
				content := resp.Value.Content["application/json-patch+json"]
				assert.NotNil(t, content)
				assert.Equal(t, "https://json.schemastore.org/json-patch", content.Schema.Ref)
				assert.Equal(t, 1, len(schemas))
			},
		},
		{
			name: "CONNECT /test",
			r: func() *http.Request {
				r := httptest.NewRequest("CONNECT", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.Equal(t, "CONNECT /test", item.Connect.Description)
			},
		},
		{
			name: "DELETE /test",
			r: func() *http.Request {
				r := httptest.NewRequest("DELETE", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.Equal(t, "DELETE /test", item.Delete.Description)
			},
		},
		{
			name: "HEAD /test",
			r: func() *http.Request {
				r := httptest.NewRequest("HEAD", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.Equal(t, "HEAD /test", item.Head.Description)
			},
		},
		{
			name: "OPTIONS /test",
			r: func() *http.Request {
				r := httptest.NewRequest("OPTIONS", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.Equal(t, "OPTIONS /test", item.Options.Description)
			},
		},
		{
			name: "PATCH /test",
			r: func() *http.Request {
				r := httptest.NewRequest("PATCH", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.Equal(t, "PATCH /test", item.Patch.Description)
			},
		},
		{
			name: "PUT /test",
			r: func() *http.Request {
				r := httptest.NewRequest("PUT", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.Equal(t, "PUT /test", item.Put.Description)
			},
		},
		{
			name: "TRACE /test",
			r: func() *http.Request {
				r := httptest.NewRequest("TRACE", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op map[string]*openapi.PathItem, schemas map[string]*openapi.SchemaRef, err error) {
				assert.NotNil(t, op)
				item, ok := op["/test"]
				assert.True(t, ok)
				assert.Equal(t, "TRACE /test", item.Trace.Description)
			},
		},
	}
	for _, tt := range tests {
		if tt.skip {
			return
		}
		t.Run(tt.name, func(t *testing.T) {
			name := ko.GenerateNameFromPath(tt.r.URL.Path, tt.r.Header.Get("X-KDex-Function-Name"))
			operationId := ko.GenerateOperationID(name, tt.r.Method, tt.r.Header.Get("X-KDex-Function-Operation-ID"))
			items, schemas, err := s.parseRequestIntoAPI(
				tt.r,
				"test",
				tt.r.URL.Path,
				operationId)
			tt.assertions(t, items, schemas, err)
		})
	}
}

func TestRequestSniffer_parseRequestIntoAPI_and_mergeAPIIntoFunction(t *testing.T) {
	fn := &kdexv1alpha1.KDexFunction{}

	s := &RequestSniffer{
		BasePathRegex: (&kdexv1alpha1.API{}).BasePathRegex(),
		HostName:      "test-host",
		ItemPathRegex: (&kdexv1alpha1.API{}).ItemPathRegex(),
	}

	// start by defining a shared schema using PUT, Accept and schema ref headers

	pattern := "/v2/users/{id}"

	r := httptest.NewRequest("PUT", "/v2/users/1", strings.NewReader(`{"name": "John","email": "john@foo.bar", "id": 1}`))
	r.Header.Set("Accept", "application/json")
	r.Header.Set("X-KDex-Function-Pattern-Path", pattern)
	r.Header.Set("X-KDex-Function-Request-Schema-Ref", "User")
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	_, patternPath, err := s.calculatePaths(r, r.Header.Get("X-KDex-Function-Pattern-Path"))
	assert.NoError(t, err)
	patternName := ko.GenerateNameFromPath(pattern, "")
	operationId := ko.GenerateOperationID(patternName, r.Method, "")
	paths, schemas, err := s.parseRequestIntoAPI(
		r,
		"test",
		patternPath,
		operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, paths, schemas, true, false)

	expected := &kdexv1alpha1.KDexFunction{
		Spec: kdexv1alpha1.KDexFunctionSpec{
			API: kdexv1alpha1.API{
				Paths: map[string]kdexv1alpha1.PathItem{
					"/v2/users/{id}": {
						Description: "Auto-generated from request to /v2/users/1",
						Put: raw(&openapi.Operation{
							Description: "PUT /v2/users/{id}",
							OperationID: "gen-v2-users-id-put",
							Parameters: openapi.Parameters{
								&openapi.ParameterRef{
									Value: &openapi.Parameter{
										Description: "Path parameter: id",
										Name:        "id",
										In:          "path",
										Required:    true,
										Schema: &openapi.SchemaRef{
											Value: &openapi.Schema{
												Type: &openapi.Types{openapi.TypeString},
											},
										},
									},
								},
							},
							RequestBody: &openapi.RequestBodyRef{
								Value: &openapi.RequestBody{
									Content: openapi.Content{
										"application/json": &openapi.MediaType{
											Schema: &openapi.SchemaRef{
												Ref: "#/components/schemas/User",
											},
										},
									},
									Description: "The request body schema",
								},
							},
							Responses: openapi.NewResponses(
								openapi.WithStatus(200, &openapi.ResponseRef{
									Value: &openapi.Response{
										Description: openapi.Ptr("Successful response"),
										Content: openapi.Content{
											"application/json": &openapi.MediaType{
												Schema: &openapi.SchemaRef{
													Ref: "#/components/schemas/User",
												},
											},
										},
									},
								}),
							),
							Summary: "gen-v2-users-id-put",
							Tags:    []string{"test"},
						}),
					},
				},
				Schemas: rawM(map[string]*openapi.SchemaRef{
					"User": {
						Value: &openapi.Schema{
							Description: "Inferred from request body",
							Type:        &openapi.Types{openapi.TypeObject},
							Properties: openapi.Schemas{
								"email": &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
								"name": &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
								"id": &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeNumber},
									},
								},
							},
						},
					},
				}),
			},
		},
	}

	assert.Equal(t, expected, fn)

	// now add GET, Accept and schema ref header

	r = httptest.NewRequest("GET", "/v2/users/1", http.NoBody)
	r.Header.Set("Accept", "application/json")
	r.Header.Set("X-KDex-Function-Pattern-Path", pattern)
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	_, patternPath, err = s.calculatePaths(r, r.Header.Get("X-KDex-Function-Pattern-Path"))
	assert.NoError(t, err)
	operationId = ko.GenerateOperationID(patternName, r.Method, "")
	paths, schemas, err = s.parseRequestIntoAPI(
		r,
		"test",
		patternPath,
		operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, paths, schemas, true, false)

	item, ok := expected.Spec.API.Paths["/v2/users/{id}"]
	assert.True(t, ok)
	item.Get = raw(&openapi.Operation{
		Description: "GET /v2/users/{id}",
		OperationID: "gen-v2-users-id-get",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithStatus(200, &openapi.ResponseRef{
				Value: &openapi.Response{
					Description: openapi.Ptr("Successful response"),
					Content: openapi.Content{
						"application/json": &openapi.MediaType{
							Schema: &openapi.SchemaRef{
								Ref: "#/components/schemas/User",
							},
						},
					},
				},
			}),
		),
		Summary: "gen-v2-users-id-get",
		Tags:    []string{"test"},
	})
	expected.Spec.API.Paths["/v2/users/{id}"] = item

	assert.Equal(t, expected, fn)

	// now add DELETE, Accept and schema ref header

	r = httptest.NewRequest("DELETE", "/v2/users/1", http.NoBody)
	r.Header.Set("Accept", "application/json")
	r.Header.Set("X-KDex-Function-Pattern-Path", pattern)
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	_, patternPath, err = s.calculatePaths(r, r.Header.Get("X-KDex-Function-Pattern-Path"))
	assert.NoError(t, err)
	operationId = ko.GenerateOperationID(patternName, r.Method, "")
	paths, schemas, err = s.parseRequestIntoAPI(
		r,
		"test",
		patternPath,
		operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, paths, schemas, true, false)

	item, ok = expected.Spec.API.Paths["/v2/users/{id}"]
	assert.True(t, ok)
	item.Delete = raw(&openapi.Operation{
		Description: "DELETE /v2/users/{id}",
		OperationID: "gen-v2-users-id-delete",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithStatus(200, &openapi.ResponseRef{
				Value: &openapi.Response{
					Description: openapi.Ptr("Successful response"),
					Content: openapi.Content{
						"application/json": &openapi.MediaType{
							Schema: &openapi.SchemaRef{
								Ref: "#/components/schemas/User",
							},
						},
					},
				},
			}),
		),
		Summary: "gen-v2-users-id-delete",
		Tags:    []string{"test"},
	})
	expected.Spec.API.Paths["/v2/users/{id}"] = item

	assert.Equal(t, expected, fn)

	// now add HEAD (existence check)

	r = httptest.NewRequest("HEAD", "/v2/users/1", http.NoBody)
	r.Header.Set("X-KDex-Function-Pattern-Path", pattern)

	_, patternPath, err = s.calculatePaths(r, r.Header.Get("X-KDex-Function-Pattern-Path"))
	assert.NoError(t, err)
	operationId = ko.GenerateOperationID(patternName, r.Method, "")
	paths, schemas, err = s.parseRequestIntoAPI(
		r,
		"test",
		patternPath,
		operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, paths, schemas, true, false)

	item, ok = expected.Spec.API.Paths["/v2/users/{id}"]
	assert.True(t, ok)
	item.Head = raw(&openapi.Operation{
		Description: "HEAD /v2/users/{id}",
		OperationID: "gen-v2-users-id-head",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithStatus(200, &openapi.ResponseRef{
				Value: &openapi.Response{
					Description: openapi.Ptr("Successful response"),
				},
			}),
		),
		Summary: "gen-v2-users-id-head",
		Tags:    []string{"test"},
	})
	expected.Spec.API.Paths["/v2/users/{id}"] = item

	assert.Equal(t, expected, fn)

	// now add PATCH, Accept and schema ref headers

	r = httptest.NewRequest("PATCH", "/v2/users/1", strings.NewReader(`[{"op": "replace", "path": "/email", "value": "john@fix.buz"}]`))
	r.Header.Set("Accept", "application/json")
	r.Header.Set("Content-Type", "application/json-patch+json")
	r.Header.Set("X-KDex-Function-Pattern-Path", pattern)
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	_, patternPath, err = s.calculatePaths(r, r.Header.Get("X-KDex-Function-Pattern-Path"))
	assert.NoError(t, err)
	operationId = ko.GenerateOperationID(patternName, r.Method, "")
	paths, schemas, err = s.parseRequestIntoAPI(
		r,
		"test",
		patternPath,
		operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, paths, schemas, true, false)

	item, ok = expected.Spec.API.Paths["/v2/users/{id}"]
	assert.True(t, ok)
	item.Patch = raw(&openapi.Operation{
		Description: "PATCH /v2/users/{id}",
		OperationID: "gen-v2-users-id-patch",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		RequestBody: &openapi.RequestBodyRef{
			Value: &openapi.RequestBody{
				Content: openapi.Content{
					"application/json-patch+json": &openapi.MediaType{
						Schema: &openapi.SchemaRef{
							Value: &openapi.Schema{
								Description: "Inferred from request body",
								Type:        &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeObject},
										Properties: openapi.Schemas{
											"op": &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
											"path": &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
											"value": &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				Description: "The request body schema",
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithStatus(200, &openapi.ResponseRef{
				Value: &openapi.Response{
					Description: openapi.Ptr("Successful response"),
					Content: openapi.Content{
						"application/json": &openapi.MediaType{
							Schema: &openapi.SchemaRef{
								Ref: "#/components/schemas/User",
							},
						},
					},
				},
			}),
		),
		Summary: "gen-v2-users-id-patch",
		Tags:    []string{"test"},
	})
	expected.Spec.API.Paths["/v2/users/{id}"] = item

	assert.Equal(t, expected, fn)
}

func TestRequestSniffer_DocsHandler(t *testing.T) {
	s := &RequestSniffer{}
	w := httptest.NewRecorder()
	r := httptest.NewRequest("GET", "/-/sniffer/docs", nil)

	s.DocsHandler(w, r)

	assert.Equal(t, 200, w.Code)
	assert.Equal(t, "text/markdown", w.Header().Get("Content-Type"))
	assert.Contains(t, w.Body.String(), "# KDex Request Sniffer Documentation")
	assert.Contains(t, w.Body.String(), "X-KDex-Function-Name")
}

func TestRequestSniffer_sniff_A(t *testing.T) {
	tests := []struct {
		name      string
		r         *http.Request
		functions []kdexv1alpha1.KDexFunction
		security  *openapi.SecurityRequirements
		want      *kdexv1alpha1.KDexFunction
		wantErr   string
	}{
		{
			name: "GET /-/internal",
			r:    httptest.NewRequest("GET", "/-/internal", http.NoBody),
			want: nil,
		},
		{
			name: "GET /v1/foo",
			r:    httptest.NewRequest("GET", "/v1/foo", http.NoBody),
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-v1-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.API{
						BasePath: "/v1/foo",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/foo": {
								Description: "Auto-generated from request to /v1/foo",
								Get: raw(&openapi.Operation{
									Description: "GET /v1/foo",
									OperationID: "gen-v1-foo-get",
									Responses: openapi.NewResponses(
										openapi.WithStatus(200, &openapi.ResponseRef{
											Value: &openapi.Response{
												Description: openapi.Ptr("Successful response"),
											},
										}),
									),
									Summary: "gen-v1-foo-get",
									Tags:    []string{"gen-v1-foo"},
								}),
							},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
						Metadata: kdexv1alpha1.Metadata{
							Tags: []string{"gen-v1-foo"},
						},
					},
				},
			},
		},
		{
			name: "GET /v1/foo request path must align with X-KDex-Function-Pattern-Path",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/v1/foo/1", http.NoBody)
				it.Header.Set("X-KDex-Function-Pattern-Path", "/v1/bar/{foo}")
				return it
			}(),
			wantErr: `request GET /v1/foo/1 does not align with pattern path "/v1/bar/{foo}"`,
		},
		{
			name: "GET /v1/foo existing is not autogenerated",
			r:    httptest.NewRequest("GET", "/v1/foo", http.NoBody),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-v1-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.API{
							BasePath: "/v1/foo",
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: false,
						},
					},
				},
			},
			wantErr: "can no longer be targeted for autogeneration",
		},
		{
			name: "GET /v1/foo with X-KDex-Function-Pattern-Path",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/v1/foo/1", http.NoBody)
				it.Header.Set("X-KDex-Function-Pattern-Path", "/v1/foo/{bar}")
				return it
			}(),
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-v1-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.API{
						BasePath: "/v1/foo",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/foo/{bar}": {
								Description: "Auto-generated from request to /v1/foo/1",
								Get: raw(&openapi.Operation{
									Description: "GET /v1/foo/{bar}",
									OperationID: "gen-v1-foo-bar-get",
									Parameters: openapi.Parameters{
										&openapi.ParameterRef{
											Value: &openapi.Parameter{
												Description: "Path parameter: bar",
												In:          "path",
												Name:        "bar",
												Required:    true,
												Schema: &openapi.SchemaRef{
													Value: &openapi.Schema{
														Type: &openapi.Types{openapi.TypeString},
													},
												},
											},
										},
									},
									Responses: openapi.NewResponses(
										openapi.WithStatus(200, &openapi.ResponseRef{
											Value: &openapi.Response{
												Description: openapi.Ptr("Successful response"),
											},
										}),
									),
									Summary: "gen-v1-foo-bar-get",
									Tags:    []string{"gen-v1-foo"},
								}),
							},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
						Metadata: kdexv1alpha1.Metadata{
							Tags: []string{"gen-v1-foo"},
						},
					},
				},
			},
		},
		{
			name: "modify existing function by adding operation",
			r:    httptest.NewRequest("GET", "/v1/foo", http.NoBody),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-v1-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.API{
							BasePath: "/v1/foo",
							Paths: map[string]kdexv1alpha1.PathItem{
								"/v1/foo": {
									Put: raw(&openapi.Operation{
										Description: "PUT /v1/foo",
										OperationID: "gen-v1-foo-put",
									}),
								},
							},
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: true,
						},
					},
				},
			},
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-v1-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.API{
						BasePath: "/v1/foo",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/foo": {
								Description: "Auto-generated from request to /v1/foo",
								Get: raw(&openapi.Operation{
									Description: "GET /v1/foo",
									OperationID: "gen-v1-foo-get",
									Responses: openapi.NewResponses(
										openapi.WithStatus(200, &openapi.ResponseRef{
											Value: &openapi.Response{
												Description: openapi.Ptr("Successful response"),
											},
										}),
									),
									Summary: "gen-v1-foo-get",
									Tags:    []string{"gen-v1-foo"},
								}),
								Put: raw(&openapi.Operation{
									Description: "PUT /v1/foo",
									OperationID: "gen-v1-foo-put",
								}),
							},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
						Metadata: kdexv1alpha1.Metadata{
							Tags: []string{"gen-v1-foo"},
						},
					},
				},
			},
		},
		{
			name: "does not modify operation without X-KDex-Function-Overwrite-Operation: true",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/v1/foo?foo=bar", http.NoBody)
				return it
			}(),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-v1-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.API{
							BasePath: "/v1/foo",
							Paths: map[string]kdexv1alpha1.PathItem{
								"/v1/foo": {
									Get: raw(&openapi.Operation{
										Description: "GET /v1/foo",
										OperationID: "gen-v1-foo-get",
									}),
								},
							},
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: true,
						},
					},
				},
			},
			wantErr: "is being skipped for safety",
		},
		{
			name: "can modify operation with X-KDex-Function-Overwrite-Operation: true",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/v1/foo?foo=bar", http.NoBody)
				it.Header.Set("X-KDex-Function-Overwrite-Operation", "true")
				return it
			}(),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-v1-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.API{
							BasePath: "/v1/foo",
							Paths: map[string]kdexv1alpha1.PathItem{
								"/v1/foo": {
									Description: "Auto-generated from request to /v1/foo",
									Get: raw(&openapi.Operation{
										Description: "GET /v1/foo",
										OperationID: "gen-v1-foo-get",
										Responses: openapi.NewResponses(
											openapi.WithStatus(200, &openapi.ResponseRef{
												Value: &openapi.Response{
													Description: openapi.Ptr("Successful response"),
												},
											}),
										),
									}),
									Summary: "Auto-generated from request to /v1/foo",
								},
							},
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: true,
						},
					},
				},
			},
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-v1-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.API{
						BasePath: "/v1/foo",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/foo": {
								Description: "Auto-generated from request to /v1/foo",
								Get: raw(&openapi.Operation{
									Description: "GET /v1/foo",
									OperationID: "gen-v1-foo-get",
									Parameters: openapi.Parameters{
										&openapi.ParameterRef{
											Value: &openapi.Parameter{
												Description: "Query parameter: foo",
												In:          "query",
												Name:        "foo",
												Required:    false,
												Schema: &openapi.SchemaRef{
													Value: &openapi.Schema{
														Type: &openapi.Types{openapi.TypeString},
													},
												},
											},
										},
									},
									Responses: openapi.NewResponses(
										openapi.WithStatus(200, &openapi.ResponseRef{
											Value: &openapi.Response{
												Description: openapi.Ptr("Successful response"),
											},
										}),
									),
									Summary: "gen-v1-foo-get",
									Tags:    []string{"gen-v1-foo"},
								}),
								Summary: "Auto-generated from request to /v1/foo",
							},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
						Metadata: kdexv1alpha1.Metadata{
							Tags: []string{"gen-v1-foo"},
						},
					},
				},
			},
		},
		{
			name: "remove a commonly defined parameter",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/v1/foo?foo=bar", http.NoBody)
				it.Header.Set("X-KDex-Function-Overwrite-Operation", "true")
				return it
			}(),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-v1-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.API{
							BasePath: "/v1/foo",
							Paths: map[string]kdexv1alpha1.PathItem{
								"/v1/foo": {
									Description: "Auto-generated from request to /v1/foo",
									Get: raw(&openapi.Operation{
										Description: "GET /v1/foo",
										OperationID: "gen-v1-foo-get",
										Responses: openapi.NewResponses(
											openapi.WithStatus(200, &openapi.ResponseRef{
												Value: &openapi.Response{
													Description: openapi.Ptr("Successful response"),
												},
											}),
										),
									}),
									Parameters: rawA([]*openapi.ParameterRef{
										{
											Value: &openapi.Parameter{
												Description: "Query parameter: foo",
												In:          "query",
												Name:        "foo",
												Required:    false,
												Schema: &openapi.SchemaRef{
													Value: &openapi.Schema{
														Type: &openapi.Types{openapi.TypeString},
													},
												},
											},
										},
									}),
									Summary: "Auto-generated from request to /v1/foo",
								},
							},
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: true,
						},
					},
				},
			},
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-v1-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.API{
						BasePath: "/v1/foo",
						Paths: map[string]kdexv1alpha1.PathItem{
							"/v1/foo": {
								Description: "Auto-generated from request to /v1/foo",
								Get: raw(&openapi.Operation{
									Description: "GET /v1/foo",
									OperationID: "gen-v1-foo-get",
									Responses: openapi.NewResponses(
										openapi.WithStatus(200, &openapi.ResponseRef{
											Value: &openapi.Response{
												Description: openapi.Ptr("Successful response"),
											},
										}),
									),
									Summary: "gen-v1-foo-get",
									Tags:    []string{"gen-v1-foo"},
								}),
								Parameters: rawA([]*openapi.ParameterRef{
									{
										Value: &openapi.Parameter{
											Description: "Query parameter: foo",
											In:          "query",
											Name:        "foo",
											Required:    false,
											Schema: &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
										},
									},
								}),
								Summary: "Auto-generated from request to /v1/foo",
							},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
						Metadata: kdexv1alpha1.Metadata{
							Tags: []string{"gen-v1-foo"},
						},
					},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := RequestSniffer{
				BasePathRegex: (&kdexv1alpha1.API{}).BasePathRegex(),
				Functions:     tt.functions,
				HostName:      "test-host",
				ItemPathRegex: (&kdexv1alpha1.API{}).ItemPathRegex(),
				Namespace:     "test-namespace",
				SecuritySchemes: &openapi.SecuritySchemes{
					"bearer": &openapi.SecuritySchemeRef{
						Value: openapi.NewJWTSecurityScheme(),
					},
				},
			}

			got, gotErr := s.sniff(tt.r)
			if gotErr != nil {
				assert.Contains(t, gotErr.Error(), tt.wantErr)
				return
			}
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestRequestSniffer_sniff(t *testing.T) {
	tests := []struct {
		name            string
		r               *http.Request
		functions       []kdexv1alpha1.KDexFunction
		securitySchemes *openapi.SecuritySchemes
		want            *kdexv1alpha1.KDexFunction
		assertions      func(t *testing.T, fn *kdexv1alpha1.KDexFunction, err error)
	}{
		{
			name: "set security, no schemes",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/v1/users/1", http.NoBody)
				r.Header.Set("X-KDex-Function-Pattern-Path", "/v1/users/{id}")
				r.Header.Set("X-KDex-Function-Security", "foo")
				return r
			}(),
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction, err error) {
				item := fn.Spec.API.Paths["/v1/users/{id}"]
				assert.NotNil(t, item)
				assert.NotNil(t, item.Get)
				assert.Nil(t, item.GetGet().Security)
			},
		},
		{
			name: "set security, with schemes, wrong scheme name",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/v1/users/1", http.NoBody)
				r.Header.Set("X-KDex-Function-Pattern-Path", "/v1/users/{id}")
				r.Header.Set("X-KDex-Function-Security", "foo")
				return r
			}(),
			securitySchemes: &openapi.SecuritySchemes{
				"bearer": &openapi.SecuritySchemeRef{
					Value: openapi.NewJWTSecurityScheme(),
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction, err error) {
				item := fn.Spec.API.Paths["/v1/users/{id}"]
				assert.NotNil(t, item)
				assert.NotNil(t, item.Get)
				assert.Nil(t, item.GetGet().Security)
			},
		},
		{
			name: "set security, with schemes, right scheme name",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/v1/users/1", http.NoBody)
				r.Header.Set("X-KDex-Function-Pattern-Path", "/v1/users/{id}")
				r.Header.Set("X-KDex-Function-Security", "bearer")
				return r
			}(),
			securitySchemes: &openapi.SecuritySchemes{
				"bearer": &openapi.SecuritySchemeRef{
					Value: openapi.NewJWTSecurityScheme(),
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction, err error) {
				item := fn.Spec.API.Paths["/v1/users/{id}"]
				assert.NotNil(t, item)
				assert.NotNil(t, item.Get)
				assert.NotNil(t, item.GetGet().Security)
				assert.NotNil(t, (*item.GetGet().Security)[0]["bearer"])
			},
		},
		{
			name: "set security, with schemes, multiple OR",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/v1/users/1", http.NoBody)
				r.Header.Set("X-KDex-Function-Pattern-Path", "/v1/users/{id}")
				r.Header.Set("X-KDex-Function-Security", "bearer;apiKey")
				return r
			}(),
			securitySchemes: &openapi.SecuritySchemes{
				"bearer": &openapi.SecuritySchemeRef{
					Value: openapi.NewJWTSecurityScheme(),
				},
				"apiKey": &openapi.SecuritySchemeRef{
					Value: openapi.NewCSRFSecurityScheme(),
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction, err error) {
				item := fn.Spec.API.Paths["/v1/users/{id}"]
				assert.NotNil(t, item)
				assert.NotNil(t, item.Get)
				assert.NotNil(t, item.GetGet().Security)
				assert.NotNil(t, (*item.GetGet().Security)[0]["bearer"])
				assert.NotNil(t, (*item.GetGet().Security)[1]["apiKey"])
			},
		},
		{
			name: "set security, with schemes, with scopes",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/v1/users/1", http.NoBody)
				r.Header.Set("X-KDex-Function-Pattern-Path", "/v1/users/{id}")
				r.Header.Set("X-KDex-Function-Security", "bearer=users:read")
				return r
			}(),
			securitySchemes: &openapi.SecuritySchemes{
				"bearer": &openapi.SecuritySchemeRef{
					Value: openapi.NewJWTSecurityScheme(),
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction, err error) {
				item := fn.Spec.API.Paths["/v1/users/{id}"]
				assert.NotNil(t, item)
				assert.NotNil(t, item.Get)
				assert.NotNil(t, item.GetGet().Security)
				bearer := (*item.GetGet().Security)[0]["bearer"]
				assert.NotNil(t, bearer)
				assert.Equal(t, []string{"users:read"}, bearer)
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := RequestSniffer{
				BasePathRegex:   (&kdexv1alpha1.API{}).BasePathRegex(),
				Functions:       tt.functions,
				HostName:        "test-host",
				ItemPathRegex:   (&kdexv1alpha1.API{}).ItemPathRegex(),
				Namespace:       "test-namespace",
				SecuritySchemes: tt.securitySchemes,
			}

			got, gotErr := s.sniff(tt.r)
			tt.assertions(t, got, gotErr)
		})
	}
}

func Test_extractSchemaName(t *testing.T) {
	tests := []struct {
		name      string
		urlString string
		want      string
		wantErr   bool
	}{
		{
			name:      "https://json.schemastore.org/json-patch",
			urlString: "https://json.schemastore.org/json-patch",
			want:      "json-patch",
		},
		{
			name:      "https://json.schemastore.org",
			urlString: "https://json.schemastore.org",
			want:      "json.schemastore.org",
		},
		{
			name:      "https://json.schemastore.org/json-patch?foo",
			urlString: "https://json.schemastore.org/json-patch?foo",
			want:      "json-patch",
		},
		{
			name:      "https://json.schemastore.org/json-patch.ext?foo",
			urlString: "https://json.schemastore.org/json-patch.ext?foo",
			want:      "json-patch.ext",
		},
		{
			name:      "https://json.schemastore.org/more/json-patch.ext?foo",
			urlString: "https://json.schemastore.org/more/json-patch.ext?foo",
			want:      "json-patch.ext",
		},
		{
			name:      "json.schemastore.org/more/json-patch.ext?foo",
			urlString: "json.schemastore.org/more/json-patch.ext?foo",
			want:      "json-patch.ext",
		},
		{
			name:      "http:///more/json-patch.ext?foo",
			urlString: "http:///more/json-patch.ext?foo",
			want:      "json-patch.ext",
		},
		{
			name:      "foo",
			urlString: "foo",
			want:      "foo",
		},
		{
			name:      "#/components/schemas/foo",
			urlString: "#/components/schemas/foo",
			want:      "foo",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, gotErr := ko.ExtractSchemaName(tt.urlString)
			if gotErr != nil {
				if !tt.wantErr {
					t.Errorf("extractSchemaName() failed: %v", gotErr)
				}
				return
			}
			if tt.wantErr {
				t.Fatal("extractSchemaName() succeeded unexpectedly")
			}
			assert.Equal(t, tt.want, got)
		})
	}
}

func raw(it any) *runtime.RawExtension {
	var raw []byte
	switch v := it.(type) {
	case *openapi.Operation:
		raw, _ = v.MarshalJSON()
	case openapi.Operation:
		raw, _ = v.MarshalJSON()
	case *openapi.Parameter:
		raw, _ = v.MarshalJSON()
	case openapi.Parameter:
		raw, _ = v.MarshalJSON()
	case *openapi.ParameterRef:
		raw, _ = v.MarshalJSON()
	case *openapi.Schema:
		raw, _ = v.MarshalJSON()
	case openapi.Schema:
		raw, _ = v.MarshalJSON()
	case *openapi.SchemaRef:
		raw, _ = v.MarshalJSON()
	case openapi.SchemaRef:
		raw, _ = v.MarshalJSON()
	default:
		panic("type unsupported")
	}

	return &runtime.RawExtension{
		Raw: raw,
	}
}

func rawA(it any) []runtime.RawExtension {
	out := []runtime.RawExtension{}
	switch v := it.(type) {
	case []openapi.Parameter:
		for _, e := range v {
			out = append(out, *raw(e))
		}
	case []*openapi.Parameter:
		for _, e := range v {
			out = append(out, *raw(e))
		}
	case []*openapi.ParameterRef:
		for _, e := range v {
			out = append(out, *raw(e))
		}
	default:
		panic("type unsupported")
	}
	return out
}

func rawM(it any) map[string]runtime.RawExtension {
	out := map[string]runtime.RawExtension{}
	switch v := it.(type) {
	case map[string]*openapi.SchemaRef:
		for k, v := range v {
			out[k] = *raw(v)
		}
	default:
		panic("type unsupported")
	}
	return out
}
