package sniffer

import (
	"bytes"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"net/textproto"
	"net/url"
	"strings"
	"testing"

	openapi "github.com/getkin/kin-openapi/openapi3"
	"github.com/stretchr/testify/assert"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kdexv1alpha1 "kdex.dev/crds/api/v1alpha1"
	ko "kdex.dev/web/internal/openapi"
)

func TestRequestSniffer_calculatePath(t *testing.T) {
	tests := []struct {
		name        string
		method      string
		requestPath string
		patternPath string
		want        string
		wantErr     bool
	}{
		{
			name:        "get root",
			method:      "GET",
			requestPath: "/",
			want:        "/",
		},
		{
			name:        "get simple path",
			method:      "GET",
			requestPath: "/users",
			want:        "/users",
		},
		{
			name:        "get with pattern match",
			method:      "GET",
			requestPath: "/users/123",
			patternPath: "/users/{id}",
			want:        "/users/{id}",
		},
		{
			name:        "get with pattern mismatch path",
			method:      "GET",
			requestPath: "/admins/123",
			patternPath: "/users/{id}",
			wantErr:     true,
		},
		{
			name:        "get with wildcard pattern",
			method:      "GET",
			requestPath: "/static/css/main.css",
			patternPath: "/static/{path...}",
			want:        "/static/{path...}",
		},
		{
			name:        "error: pattern with method",
			method:      "GET",
			requestPath: "/users/123",
			patternPath: "GET /users/{id}",
			wantErr:     true,
		},
		{
			name:        "error: pattern without leading slash",
			method:      "GET",
			requestPath: "/users/123",
			patternPath: "users/{id}",
			wantErr:     true,
		},
		{
			name:        "invalid pattern format",
			method:      "GET",
			requestPath: "/users",
			patternPath: "/{",
			wantErr:     true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var s RequestSniffer
			r := httptest.NewRequest(tt.method, tt.requestPath, &io.PipeReader{})
			got, gotErr := s.calculatePath(r, tt.patternPath)
			if tt.wantErr {
				assert.Error(t, gotErr)
				return
			}
			assert.NoError(t, gotErr)
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestRequestSniffer_matchExisting(t *testing.T) {
	items := []kdexv1alpha1.KDexFunction{
		{
			ObjectMeta: metav1.ObjectMeta{Name: "gen-users"},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				API: kdexv1alpha1.KDexOpenAPI{
					Path: "/users",
					KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
						Get: &openapi.Operation{
							OperationID: "gen-users-get",
						},
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{AutoGenerated: true},
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{Name: "gen-posts"},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				API: kdexv1alpha1.KDexOpenAPI{
					Path: "/posts",
					KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
						Post: &openapi.Operation{
							OperationID: "gen-posts-post",
						},
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{AutoGenerated: false},
			},
		},
	}

	tests := []struct {
		name                 string
		headerFunctionName   string
		headerOperationId    string
		path                 string
		method               string
		wantExistingName     string
		wantExactMethodMatch bool
	}{
		{
			name:                 "exact match autogenerated",
			path:                 "/users",
			method:               "GET",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: true,
		},
		{
			name:                 "exact match manual",
			path:                 "/posts",
			method:               "POST",
			wantExistingName:     "gen-posts",
			wantExactMethodMatch: true,
		},
		{
			name:                 "path match but new method",
			path:                 "/users",
			method:               "POST",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: false,
		},
		{
			name:                 "no match",
			path:                 "/unknown",
			method:               "GET",
			wantExistingName:     "",
			wantExactMethodMatch: false,
		},
		{
			name:                 "match by name header",
			path:                 "/unknown",
			method:               "GET",
			headerFunctionName:   "gen-users",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: false,
		},
		{
			name:                 "match by operation id header",
			path:                 "/users",
			method:               "GET",
			headerFunctionName:   "foo",
			headerOperationId:    "gen-users-get",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			name := ko.GenerateNameFromPath(tt.path, tt.headerFunctionName)
			operationId := ko.GenerateOperationID(name, tt.method, tt.headerOperationId)

			s := &RequestSniffer{}
			gotExisting, gotExact := s.matchExisting(items, name, tt.path, tt.method, operationId)
			if tt.wantExistingName == "" {
				assert.Nil(t, gotExisting)
			} else {
				assert.NotNil(t, gotExisting)
				assert.Equal(t, tt.wantExistingName, gotExisting.Name)
			}
			assert.Equal(t, tt.wantExactMethodMatch, gotExact)
		})
	}
}

func TestRequestSniffer_mergeAPIIntoFunction(t *testing.T) {
	s := &RequestSniffer{HostName: "test-host"}

	tests := []struct {
		name          string
		api           *kdexv1alpha1.KDexOpenAPIInternal
		path          string
		fn            *kdexv1alpha1.KDexFunction
		keepConflicts bool
		assertions    func(t *testing.T, fn *kdexv1alpha1.KDexFunction)
	}{
		{
			name:       "no op",
			fn:         &kdexv1alpha1.KDexFunction{},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {},
		},
		{
			name: "add connect",
			fn:   &kdexv1alpha1.KDexFunction{},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Connect: &openapi.Operation{
					Description: "CONNECT /path",
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "CONNECT /path", fn.Spec.API.Connect.Description)
			},
		},
		{
			name: "add delete",
			fn:   &kdexv1alpha1.KDexFunction{},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Delete: &openapi.Operation{
					Description: "DELETE /path",
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "DELETE /path", fn.Spec.API.Delete.Description)
			},
		},
		{
			name: "add head",
			fn:   &kdexv1alpha1.KDexFunction{},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Head: &openapi.Operation{
					Description: "HEAD /path",
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "HEAD /path", fn.Spec.API.Head.Description)
			},
		},
		{
			name: "add options",
			fn:   &kdexv1alpha1.KDexFunction{},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Options: &openapi.Operation{
					Description: "OPTIONS /path",
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "OPTIONS /path", fn.Spec.API.Options.Description)
			},
		},
		{
			name: "add patch",
			fn:   &kdexv1alpha1.KDexFunction{},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Patch: &openapi.Operation{
					Description: "PATCH /path",
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "PATCH /path", fn.Spec.API.Patch.Description)
			},
		},
		{
			name: "add post",
			fn:   &kdexv1alpha1.KDexFunction{},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Post: &openapi.Operation{
					Description: "POST /path",
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "POST /path", fn.Spec.API.Post.Description)
			},
		},
		{
			name: "add put",
			fn:   &kdexv1alpha1.KDexFunction{},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Put: &openapi.Operation{
					Description: "PUT /path",
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "PUT /path", fn.Spec.API.Put.Description)
			},
		},
		{
			name: "add trace",
			fn:   &kdexv1alpha1.KDexFunction{},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Trace: &openapi.Operation{
					Description: "TRACE /path",
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "TRACE /path", fn.Spec.API.Trace.Description)
			},
		},
		{
			name: "set path",
			fn:   &kdexv1alpha1.KDexFunction{},
			api:  &kdexv1alpha1.KDexOpenAPIInternal{},
			path: "/foo",
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "/foo", fn.Spec.API.Path)
				assert.Equal(t, "Auto-generated from request to /foo", fn.Spec.API.Description)
			},
		},
		{
			name: "add parameter to none",
			fn:   &kdexv1alpha1.KDexFunction{},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Parameters: []openapi.Parameter{
					{
						Name: "foo",
						In:   "query",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "foo", fn.Spec.API.Parameters[0].Name)
				assert.Equal(t, "query", fn.Spec.API.Parameters[0].In)
			},
		},
		{
			name: "add parameter to some",
			fn: &kdexv1alpha1.KDexFunction{
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Parameters: []openapi.Parameter{
								{
									Name: "foo",
									In:   "query",
								},
							},
						},
					},
				},
			},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Parameters: []openapi.Parameter{
					{
						Name: "bar",
						In:   "path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "foo", fn.Spec.API.Parameters[0].Name)
				assert.Equal(t, "query", fn.Spec.API.Parameters[0].In)
				assert.Equal(t, "bar", fn.Spec.API.Parameters[1].Name)
				assert.Equal(t, "path", fn.Spec.API.Parameters[1].In)
			},
		},
		{
			name: "add existing parameter different in",
			fn: &kdexv1alpha1.KDexFunction{
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Parameters: []openapi.Parameter{
								{
									Name: "foo",
									In:   "query",
								},
							},
						},
					},
				},
			},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Parameters: []openapi.Parameter{
					{
						Name: "foo",
						In:   "path",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "foo", fn.Spec.API.Parameters[0].Name)
				assert.Equal(t, "query", fn.Spec.API.Parameters[0].In)
				assert.Equal(t, "foo", fn.Spec.API.Parameters[1].Name)
				assert.Equal(t, "path", fn.Spec.API.Parameters[1].In)
			},
		},
		{
			name: "add existing parameter same in",
			fn: &kdexv1alpha1.KDexFunction{
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Parameters: []openapi.Parameter{
								{
									Name: "foo",
									In:   "query",
								},
							},
						},
					},
				},
			},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Parameters: []openapi.Parameter{
					{
						Name: "foo",
						In:   "query",
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "foo", fn.Spec.API.Parameters[0].Name)
				assert.Equal(t, "query", fn.Spec.API.Parameters[0].In)
				assert.Equal(t, 1, len(fn.Spec.API.Parameters))
			},
		},
		{
			name: "add new schema",
			fn:   &kdexv1alpha1.KDexFunction{},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Schemas: map[string]openapi.Schema{
					"User": {
						Type: &openapi.Types{openapi.TypeObject},
					},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				s, ok := fn.Spec.API.Schemas["#/components/schemas/User"]
				assert.Equal(t, true, ok)
				assert.Equal(t, &openapi.Types{openapi.TypeObject}, s.Type)
			},
		},
		{
			name: "add conflicting schema",
			fn: &kdexv1alpha1.KDexFunction{
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Schemas: map[string]openapi.Schema{
								"#/components/schemas/User": {
									Description: "Existing User",
									Type:        &openapi.Types{openapi.TypeObject},
								},
							},
						},
					},
				},
			},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Schemas: map[string]openapi.Schema{
					"#/components/schemas/User": {
						Description: "Conflicting User",
						Type:        &openapi.Types{openapi.TypeObject},
					},
				},
			},
			path:          "/foo",
			keepConflicts: true,
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				s, ok := fn.Spec.API.Schemas["#/components/schemas/User"]
				assert.Equal(t, true, ok)
				assert.Equal(t, "Existing User", s.Description)
				assert.Equal(t, 2, len(fn.Spec.API.Schemas))
				s2, ok := fn.Spec.API.Schemas["#/components/schemas/User_conflict_"+ko.GenerateNameFromPath(fn.Spec.API.Path, "")]
				assert.Equal(t, true, ok)
				assert.Equal(t, "Conflicting User", s2.Description)
			},
		},
		{
			name: "add trace to existing",
			fn: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name: "gen-path",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						Path: "/path",
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Get: &openapi.Operation{
								Description: "GET /path",
							},
						},
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
				},
			},
			api: &kdexv1alpha1.KDexOpenAPIInternal{
				Trace: &openapi.Operation{
					Description: "TRACE /path",
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "GET /path", fn.Spec.API.Get.Description)
				assert.Equal(t, "TRACE /path", fn.Spec.API.Trace.Description)
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s.mergeAPIIntoFunction(tt.fn, tt.api, tt.path, tt.keepConflicts)
			tt.assertions(t, tt.fn)
		})
	}
}

func TestRequestSniffer_parseRequestIntoAPI(t *testing.T) {
	s := &RequestSniffer{
		SecurityModes: []string{"bearer"},
	}

	tests := []struct {
		name       string
		r          *http.Request
		assertions func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error)
		skip       bool
	}{
		{
			name: "GET /foo",
			r:    httptest.NewRequest("GET", "/foo", http.NoBody),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Get)
				assert.Equal(t, "gen-foo-get", in.Get.OperationID)
				assert.Nil(t, in.Get.Security)
			},
		},
		{
			name: "GET /foo with tags",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("X-KDex-Function-Tags", "one,two,three")
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Get)
				assert.Equal(t, "gen-foo-get", in.Get.OperationID)
				assert.Equal(t, []string{"one", "two", "three"}, in.Get.Tags)
			},
		},
		{
			name: "GET /foo with description and summary",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("X-KDex-Function-Description", "custom description")
				r.Header.Add("X-KDex-Function-Summary", "custom summary")
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Get)
				assert.Equal(t, "gen-foo-get", in.Get.OperationID)
				assert.Equal(t, "custom description", in.Get.Description)
				assert.Equal(t, "custom summary", in.Get.Summary)
			},
		},
		{
			name: "GET /foo without Accept: produces default schemaless response",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Get)
				assert.Equal(t, "gen-foo-get", in.Get.OperationID)
				assert.Equal(t, 1, in.Get.Responses.Len())
				assert.NotNil(t, in.Get.Responses.Default())
				assert.Equal(t, openapi.Ptr("Successful response"), in.Get.Responses.Default().Value.Description)
				assert.Equal(t, 0, len(in.Get.Responses.Default().Value.Content))
			},
		},
		{
			name: "GET /foo with Accept: *\\* produces schemaless response",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("Accept", "*/*")
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Get)
				assert.Equal(t, "gen-foo-get", in.Get.OperationID)
				assert.Equal(t, 1, in.Get.Responses.Len())
				assert.NotNil(t, in.Get.Responses.Default())
				assert.Equal(t, openapi.Ptr("Successful response"), in.Get.Responses.Default().Value.Description)
				assert.Equal(t, 0, len(in.Get.Responses.Default().Value.Content))
			},
		},
		{
			name: "GET /foo with specific Accept: produces schema response",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("Accept", "application/json")
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Get)
				assert.Equal(t, "gen-foo-get", in.Get.OperationID)
				assert.Equal(t, 1, in.Get.Responses.Len())

				resp := in.Get.Responses.Default()

				assert.NotNil(t, resp)
				assert.Equal(t, openapi.Ptr("Successful response"), resp.Value.Description)
				assert.Equal(t, 1, len(resp.Value.Content))
				assert.NotNil(t, resp.Value.Content.Get("application/json").Schema)
				assert.Nil(t, resp.Value.Content.Get("application/json").Schema.Value.Type)
			},
		},
		{
			name: "GET /foo with specific Accept: and set X-KDex-Function-Response-Schema-Ref",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("Accept", "application/json")
				r.Header.Add("X-KDex-Function-Response-Schema-Ref", "Foo")
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Get)
				assert.Equal(t, "gen-foo-get", in.Get.OperationID)
				assert.Equal(t, 1, in.Get.Responses.Len())

				resp := in.Get.Responses.Default()

				assert.NotNil(t, resp)
				assert.Equal(t, openapi.Ptr("Successful response"), resp.Value.Description)
				assert.Equal(t, 1, len(resp.Value.Content))
				assert.NotNil(t, resp.Value.Content.Get("application/json").Schema)
				assert.Equal(t, "#/components/schemas/Foo", resp.Value.Content.Get("application/json").Schema.Ref)
			},
		},
		{
			name: "detect auth",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Set("Authorization", "Bearer token")
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Get)
				assert.Equal(t, "gen-foo-get", in.Get.OperationID)
				assert.NotNil(t, in.Get.Security)
				assert.Len(t, *in.Get.Security, 1)
				assert.Contains(t, (*in.Get.Security)[0], "bearer")
			},
		},
		{
			name: "query array",
			r:    httptest.NewRequest("GET", "/test?id=1&id=2", http.NoBody),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Get)
				assert.Equal(t, "gen-test-get", in.Get.OperationID)
				found := false
				for _, p := range in.Get.Parameters {
					if p.Value.Name == "id" {
						assert.True(t, p.Value.Schema.Value.Type.Is("array"))
						found = true
					}
				}
				assert.True(t, found)
			},
		},
		{
			name: "json schema inference",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", strings.NewReader(`
{
	"name": "John",
	"age": 30,
	"active": true,
	"tags": [
		"ai",
		"google"
	],
	"address": {
		"line1": "123 The Road",
		"Country": "BQ"
	}
}`))
				r.Header.Set("Content-Type", "application/json")
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				expected := openapi.Schema{
					Type: &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"name": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"age": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeNumber},
							},
						},
						"active": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeBoolean},
							},
						},
						"tags": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
						"address": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeObject},
								Properties: openapi.Schemas{
									"line1": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
									"Country": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
								},
							},
						},
					},
				}

				assert.NotNil(t, in.Post)
				assert.NotNil(t, in.Post.RequestBody)
				content := in.Post.RequestBody.Value.Content["application/json"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect json schema and do inference",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", strings.NewReader(`
{
	"name": "John",
	"age": 30,
	"active": true,
	"tags": [
		"ai",
		"google"
	],
	"address": {
		"line1": "123 The Road",
		"Country": "BQ"
	}
}`))
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				expected := openapi.Schema{
					Type: &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"name": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"age": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeNumber},
							},
						},
						"active": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeBoolean},
							},
						},
						"tags": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
						"address": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeObject},
								Properties: openapi.Schemas{
									"line1": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
									"Country": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
								},
							},
						},
					},
				}

				assert.NotNil(t, in.Post)
				assert.NotNil(t, in.Post.RequestBody)
				content := in.Post.RequestBody.Value.Content["application/json"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect application\\octet-stream",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", bytes.NewReader([]byte{123, 23, 34, 145, 233}))
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				expected := openapi.Schema{
					Type:   &openapi.Types{openapi.TypeString},
					Format: "binary",
				}

				assert.NotNil(t, in.Post)
				assert.NotNil(t, in.Post.RequestBody)
				content := in.Post.RequestBody.Value.Content["application/octet-stream"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect application\\x-www-form-urlencoded and schema",
			r: func() *http.Request {
				data := url.Values{}
				data.Set("name", "John Doe")
				data.Set("email", "john@example.com")
				data.Set("occupation", "Software Engineer")
				encodedData := data.Encode()
				r := httptest.NewRequest("POST", "/test", strings.NewReader(encodedData))
				r.Header.Set("Content-Type", "application/x-www-form-urlencoded")
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				expected := openapi.Schema{
					Type: &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"name": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"email": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"occupation": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
					},
				}

				assert.NotNil(t, in.Post)
				assert.NotNil(t, in.Post.RequestBody)
				content := in.Post.RequestBody.Value.Content["application/x-www-form-urlencoded"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect mutlipart\\form-data and schema",
			r: func() *http.Request {
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)
				_ = writer.WriteField("username", "gopher_fan")
				_ = writer.WriteField("type", "admin")
				part, _ := writer.CreateFormFile("profile_pic", "image.svg")
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))
				writer.Close()
				r := httptest.NewRequest("POST", "/test", body)
				r.Header.Set("Content-Type", writer.FormDataContentType())
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				expectedSchema := openapi.Schema{
					Type: &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"username": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"type": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"profile_pic": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Format: "binary",
								Type:   &openapi.Types{openapi.TypeString},
							},
						},
					},
				}
				expectedEncoding := map[string]*openapi.Encoding{
					"profile_pic": {
						ContentType: "image/svg+xml",
					},
				}

				assert.NotNil(t, in.Post)
				assert.NotNil(t, in.Post.RequestBody)
				content := in.Post.RequestBody.Value.Content["multipart/form-data"]
				assert.NotNil(t, content)
				assert.Equal(t, &expectedSchema, content.Schema.Value)
				assert.Equal(t, expectedEncoding, content.Encoding)
			},
		},
		{
			name: "mutlipart\\form-data with content type and schema",
			r: func() *http.Request {
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)
				_ = writer.WriteField("username", "gopher_fan")
				h := make(textproto.MIMEHeader)
				h.Set("Content-Disposition", `form-data; name="profile_pic"; filename="image.svg"`)
				h.Set("Content-Type", "image/svg+xml")
				part, _ := writer.CreatePart(h)
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))
				writer.Close()
				r := httptest.NewRequest("POST", "/test", body)
				r.Header.Set("Content-Type", writer.FormDataContentType())
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				expectedSchema := openapi.Schema{
					Type: &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"username": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"profile_pic": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Format: "binary",
								Type:   &openapi.Types{openapi.TypeString},
							},
						},
					},
				}
				expectedEncoding := map[string]*openapi.Encoding{
					"profile_pic": {
						ContentType: "image/svg+xml",
					},
				}

				assert.NotNil(t, in.Post)
				assert.NotNil(t, in.Post.RequestBody)
				content := in.Post.RequestBody.Value.Content["multipart/form-data"]
				assert.NotNil(t, content)
				assert.Equal(t, &expectedSchema, content.Schema.Value)
				assert.Equal(t, expectedEncoding, content.Encoding)
			},
		},
		{
			name: "mutlipart\\form-data with content type, arrays schema",
			r: func() *http.Request {
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)
				_ = writer.WriteField("username", "gopher_fan")
				_ = writer.WriteField("username", "bear_dude")

				// array file 1
				h := make(textproto.MIMEHeader)
				h.Set("Content-Disposition", `form-data; name="profile_pic"; filename="one.svg"`)
				h.Set("Content-Type", "image/svg+xml")
				part, _ := writer.CreatePart(h)
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))

				// array file 2
				h = make(textproto.MIMEHeader)
				h.Set("Content-Disposition", `form-data; name="profile_pic"; filename="two.svg"`)
				h.Set("Content-Type", "image/svg+xml")
				part, _ = writer.CreatePart(h)
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))

				writer.Close()
				r := httptest.NewRequest("POST", "/test", body)
				r.Header.Set("Content-Type", writer.FormDataContentType())
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				expectedSchema := openapi.Schema{
					Type: &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"username": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
						"profile_pic": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type:   &openapi.Types{openapi.TypeString},
										Format: "binary",
									},
								},
							},
						},
					},
				}
				expectedEncoding := map[string]*openapi.Encoding{
					"profile_pic": {
						ContentType: "image/svg+xml",
					},
				}

				assert.NotNil(t, in.Post)
				assert.NotNil(t, in.Post.RequestBody)
				content := in.Post.RequestBody.Value.Content["multipart/form-data"]
				assert.NotNil(t, content)
				assert.Equal(t, &expectedSchema, content.Schema.Value)
				assert.Equal(t, expectedEncoding, content.Encoding)
			},
		},
		{
			name: "override response schema",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", strings.NewReader(`{}`))
				r.Header.Set("X-KDex-Function-Request-Schema-Ref", "Foo")
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Post)
				assert.NotNil(t, in.Post.RequestBody)
				content := in.Post.RequestBody.Value.Content["application/json"]
				assert.NotNil(t, content)
				assert.Equal(t, "#/components/schemas/Foo", content.Schema.Ref)
				sharedSchema := in.Schemas["#/components/schemas/Foo"]
				assert.NotNil(t, sharedSchema)
			},
		},
		{
			name: "CONNECT /test",
			r: func() *http.Request {
				r := httptest.NewRequest("CONNECT", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Connect)
				assert.Equal(t, "CONNECT /test", in.Connect.Description)
			},
		},
		{
			name: "DELETE /test",
			r: func() *http.Request {
				r := httptest.NewRequest("DELETE", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Delete)
				assert.Equal(t, "DELETE /test", in.Delete.Description)
			},
		},
		{
			name: "HEAD /test",
			r: func() *http.Request {
				r := httptest.NewRequest("HEAD", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Head)
				assert.Equal(t, "HEAD /test", in.Head.Description)
			},
		},
		{
			name: "OPTIONS /test",
			r: func() *http.Request {
				r := httptest.NewRequest("OPTIONS", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Options)
				assert.Equal(t, "OPTIONS /test", in.Options.Description)
			},
		},
		{
			name: "PATCH /test",
			r: func() *http.Request {
				r := httptest.NewRequest("PATCH", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Patch)
				assert.Equal(t, "PATCH /test", in.Patch.Description)
			},
		},
		{
			name: "PUT /test",
			r: func() *http.Request {
				r := httptest.NewRequest("PUT", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Put)
				assert.Equal(t, "PUT /test", in.Put.Description)
			},
		},
		{
			name: "TRACE /test",
			r: func() *http.Request {
				r := httptest.NewRequest("TRACE", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, in *kdexv1alpha1.KDexOpenAPIInternal, err error) {
				assert.NotNil(t, in.Trace)
				assert.Equal(t, "TRACE /test", in.Trace.Description)
			},
		},
	}
	for _, tt := range tests {
		if tt.skip {
			return
		}
		t.Run(tt.name, func(t *testing.T) {
			name := ko.GenerateNameFromPath(tt.r.URL.Path, tt.r.Header.Get("X-KDex-Function-Name"))
			operationId := ko.GenerateOperationID(name, tt.r.Method, tt.r.Header.Get("X-KDex-Function-Operation-ID"))
			got, err := s.parseRequestIntoAPI(tt.r, ko.GenerateNameFromPath(tt.r.URL.Path, ""), tt.r.Method, tt.r.URL.Path, operationId)
			tt.assertions(t, got, err)
		})
	}
}

func TestRequestSniffer_parseRequestIntoAPI_and_mergeAPIIntoFunction(t *testing.T) {
	fn := &kdexv1alpha1.KDexFunction{}

	s := &RequestSniffer{}

	// start by defining a shared schema using PUT, Accept and schema ref headers

	r := httptest.NewRequest("PUT", "/users/{id}", strings.NewReader(`{"name": "John","email": "john@foo.bar"}`))
	r.Header.Set("Accept", "application/json")
	r.Header.Set("X-KDex-Function-Request-Schema-Ref", "User")
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	name := ko.GenerateNameFromPath(r.URL.Path, "")
	operationId := ko.GenerateOperationID(name, r.Method, "")
	in, err := s.parseRequestIntoAPI(r, ko.GenerateNameFromPath(r.URL.Path, ""), r.Method, r.URL.Path, operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, in, "/users/{id}", false)

	expected := &kdexv1alpha1.KDexFunction{
		Spec: kdexv1alpha1.KDexFunctionSpec{
			API: kdexv1alpha1.KDexOpenAPI{
				Description: "Auto-generated from request to /users/{id}",
				Path:        "/users/{id}",
				KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
					Put: &openapi.Operation{
						Description: "PUT /users/{id}",
						OperationID: "gen-users-id-put",
						Parameters: openapi.Parameters{
							&openapi.ParameterRef{
								Value: &openapi.Parameter{
									Description: "Path parameter: id",
									Name:        "id",
									In:          "path",
									Required:    true,
									Schema: &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
								},
							},
						},
						RequestBody: &openapi.RequestBodyRef{
							Value: &openapi.RequestBody{
								Content: openapi.Content{
									"application/json": &openapi.MediaType{
										Schema: &openapi.SchemaRef{
											Ref: "#/components/schemas/User",
										},
									},
								},
							},
						},
						Responses: openapi.NewResponses(
							openapi.WithName("default", &openapi.Response{
								Description: openapi.Ptr("Successful response"),
								Content: openapi.Content{
									"application/json": &openapi.MediaType{
										Schema: &openapi.SchemaRef{
											Ref: "#/components/schemas/User",
										},
									},
								},
							}),
						),
						Summary: "gen-users-id",
					},
					Schemas: map[string]openapi.Schema{
						"#/components/schemas/User": {
							Type: &openapi.Types{openapi.TypeObject},
							Properties: openapi.Schemas{
								"email": &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
								"name": &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
					},
				},
			},
			Metadata: kdexv1alpha1.KDexFunctionMetadata{
				AutoGenerated: true,
			},
			Function: kdexv1alpha1.KDexFunctionExec{
				Language:    "go",
				Environment: "go-env",
			},
		},
	}

	assert.Equal(t, expected, fn)

	// now add GET, Accept and schema ref header

	r = httptest.NewRequest("GET", "/users/{id}", http.NoBody)
	r.Header.Set("Accept", "application/json")
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	name = ko.GenerateNameFromPath(r.URL.Path, "")
	operationId = ko.GenerateOperationID(name, r.Method, "")
	in, err = s.parseRequestIntoAPI(r, ko.GenerateNameFromPath(r.URL.Path, ""), r.Method, r.URL.Path, operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, in, "/users/{id}", false)

	expected.Spec.API.Get = &openapi.Operation{
		Description: "GET /users/{id}",
		OperationID: "gen-users-id-get",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithName("default", &openapi.Response{
				Description: openapi.Ptr("Successful response"),
				Content: openapi.Content{
					"application/json": &openapi.MediaType{
						Schema: &openapi.SchemaRef{
							Ref: "#/components/schemas/User",
						},
					},
				},
			}),
		),
		Summary: "gen-users-id",
	}

	assert.Equal(t, expected, fn)

	// now add DELETE, Accept and schema ref header

	r = httptest.NewRequest("DELETE", "/users/{id}", http.NoBody)
	r.Header.Set("Accept", "application/json")
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	name = ko.GenerateNameFromPath(r.URL.Path, "")
	operationId = ko.GenerateOperationID(name, r.Method, "")
	in, err = s.parseRequestIntoAPI(r, ko.GenerateNameFromPath(r.URL.Path, ""), r.Method, r.URL.Path, operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, in, "/users/{id}", false)

	expected.Spec.API.Delete = &openapi.Operation{
		Description: "DELETE /users/{id}",
		OperationID: "gen-users-id-delete",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithName("default", &openapi.Response{
				Description: openapi.Ptr("Successful response"),
				Content: openapi.Content{
					"application/json": &openapi.MediaType{
						Schema: &openapi.SchemaRef{
							Ref: "#/components/schemas/User",
						},
					},
				},
			}),
		),
		Summary: "gen-users-id",
	}

	assert.Equal(t, expected, fn)

	// now add HEAD (existence check)

	r = httptest.NewRequest("HEAD", "/users/{id}", http.NoBody)

	name = ko.GenerateNameFromPath(r.URL.Path, "")
	operationId = ko.GenerateOperationID(name, r.Method, "")
	in, err = s.parseRequestIntoAPI(r, ko.GenerateNameFromPath(r.URL.Path, ""), r.Method, r.URL.Path, operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, in, "/users/{id}", false)

	expected.Spec.API.Head = &openapi.Operation{
		Description: "HEAD /users/{id}",
		OperationID: "gen-users-id-head",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithName("default", &openapi.Response{
				Description: openapi.Ptr("Successful response"),
			}),
		),
		Summary: "gen-users-id",
	}

	assert.Equal(t, expected, fn)

	// now add PATCH, Accept and schema ref headers

	r = httptest.NewRequest("PATCH", "/users/{id}", strings.NewReader(`[{"op": "replace", "path": "/email", "value": "john@fix.buz"}]`))
	r.Header.Set("Accept", "application/json")
	r.Header.Set("Content-Type", "application/json-patch+json")
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	name = ko.GenerateNameFromPath(r.URL.Path, "")
	operationId = ko.GenerateOperationID(name, r.Method, "")
	in, err = s.parseRequestIntoAPI(r, ko.GenerateNameFromPath(r.URL.Path, ""), r.Method, r.URL.Path, operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, in, "/users/{id}", false)

	expectedPatch := &openapi.Operation{
		Description: "PATCH /users/{id}",
		OperationID: "gen-users-id-patch",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		RequestBody: &openapi.RequestBodyRef{
			Value: &openapi.RequestBody{
				Content: openapi.Content{
					"application/json-patch+json": &openapi.MediaType{
						Schema: &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeObject},
										Properties: openapi.Schemas{
											"op": &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
											"path": &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
											"value": &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithName("default", &openapi.Response{
				Description: openapi.Ptr("Successful response"),
				Content: openapi.Content{
					"application/json": &openapi.MediaType{
						Schema: &openapi.SchemaRef{
							Ref: "#/components/schemas/User",
						},
					},
				},
			}),
		),
		Summary: "gen-users-id",
	}

	fnPatch := fn.Spec.API.Patch
	fn.Spec.API.Patch = nil

	assert.Equal(t, expected, fn)
	assert.Equal(t, expectedPatch, fnPatch)
}

func TestRequestSniffer_DocsHandler(t *testing.T) {
	s := &RequestSniffer{}
	w := httptest.NewRecorder()
	r := httptest.NewRequest("GET", "/~/sniffer/docs", nil)

	s.DocsHandler(w, r)

	assert.Equal(t, 200, w.Code)
	assert.Equal(t, "text/markdown", w.Header().Get("Content-Type"))
	assert.Contains(t, w.Body.String(), "# KDex Request Sniffer Documentation")
	assert.Contains(t, w.Body.String(), "X-KDex-Function-Name")
}

func TestRequestSniffer_sniff(t *testing.T) {
	tests := []struct {
		name          string
		r             *http.Request
		functions     []kdexv1alpha1.KDexFunction
		securityModes []string
		want          *kdexv1alpha1.KDexFunction
		wantErr       bool
	}{
		{
			name: "GET /~/internal",
			r:    httptest.NewRequest("GET", "/~/internal", http.NoBody),
			want: nil,
		},
		{
			name: "GET /foo",
			r:    httptest.NewRequest("GET", "/foo", http.NoBody),
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						Description: "Auto-generated from request to /foo",
						Path:        "/foo",
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Get: &openapi.Operation{
								Description: "GET /foo",
								OperationID: "gen-foo-get",
								Responses: openapi.NewResponses(
									openapi.WithName("default", &openapi.Response{
										Description: openapi.Ptr("Successful response"),
									}),
								),
								Summary: "gen-foo",
							},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
				},
			},
		},
		{
			name: "GET /foo with bad X-KDex-Function-Pattern-Path",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/foo", http.NoBody)
				it.Header.Set("X-KDex-Function-Pattern-Path", "/bar")
				return it
			}(),
			wantErr: true,
		},
		{
			name: "GET /foo existing is not autogenerated",
			r:    httptest.NewRequest("GET", "/foo", http.NoBody),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.KDexOpenAPI{
							Path: "/foo",
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: false,
						},
					},
				},
			},
			wantErr: true,
		},
		{
			name: "GET /foo with X-KDex-Function-Pattern-Path",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/foo", http.NoBody)
				it.Header.Set("X-KDex-Function-Pattern-Path", "/{bar}")
				return it
			}(),
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-bar",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						Description: "Auto-generated from request to /{bar}",
						Path:        "/{bar}",
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Get: &openapi.Operation{
								Description: "GET /{bar}",
								OperationID: "gen-bar-get",
								Parameters: openapi.Parameters{
									&openapi.ParameterRef{
										Value: &openapi.Parameter{
											Description: "Path parameter: bar",
											In:          "path",
											Name:        "bar",
											Required:    true,
											Schema: &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
										},
									},
								},
								Responses: openapi.NewResponses(
									openapi.WithName("default", &openapi.Response{
										Description: openapi.Ptr("Successful response"),
									}),
								),
								Summary: "gen-bar",
							},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
				},
			},
		},
		{
			name: "modify existing function by adding operation",
			r:    httptest.NewRequest("GET", "/foo", http.NoBody),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.KDexOpenAPI{
							Path: "/foo",
							KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
								Put: &openapi.Operation{
									Description: "PUT /foo",
									OperationID: "gen-foo-put",
								},
							},
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: true,
						},
					},
				},
			},
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						Description: "Auto-generated from request to /foo",
						Path:        "/foo",
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Get: &openapi.Operation{
								Description: "GET /foo",
								OperationID: "gen-foo-get",
								Responses: openapi.NewResponses(
									openapi.WithName("default", &openapi.Response{
										Description: openapi.Ptr("Successful response"),
									}),
								),
								Summary: "gen-foo",
							},
							Put: &openapi.Operation{
								Description: "PUT /foo",
								OperationID: "gen-foo-put",
							},
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
				},
			},
		},
		{
			name: "does not modify operation without X-KDex-Function-Overwrite-Operation: true",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/foo?foo=bar", http.NoBody)
				return it
			}(),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.KDexOpenAPI{
							Path: "/foo",
							KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
								Get: &openapi.Operation{
									Description: "GET /foo",
									OperationID: "gen-foo-get",
								},
							},
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: true,
						},
					},
				},
			},
			wantErr: true,
		},
		{
			name: "can modify operation with X-KDex-Function-Overwrite-Operation: true",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/foo?foo=bar", http.NoBody)
				it.Header.Set("X-KDex-Function-Overwrite-Operation", "true")
				return it
			}(),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.KDexOpenAPI{
							Description: "Auto-generated from request to /foo",
							Path:        "/foo",
							KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
								Get: &openapi.Operation{
									Description: "GET /foo",
									OperationID: "gen-foo-get",
									Responses: openapi.NewResponses(
										openapi.WithName("default", &openapi.Response{
											Description: openapi.Ptr("Successful response"),
										}),
									),
								},
							},
							Summary: "Auto-generated from request to /foo",
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: true,
						},
					},
				},
			},
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						Description: "Auto-generated from request to /foo",
						Path:        "/foo",
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Get: &openapi.Operation{
								Description: "GET /foo",
								OperationID: "gen-foo-get",
								Parameters: openapi.Parameters{
									&openapi.ParameterRef{
										Value: &openapi.Parameter{
											Description: "Query parameter: foo",
											In:          "query",
											Name:        "foo",
											Required:    false,
											Schema: &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
										},
									},
								},
								Responses: openapi.NewResponses(
									openapi.WithName("default", &openapi.Response{
										Description: openapi.Ptr("Successful response"),
									}),
								),
								Summary: "gen-foo",
							},
						},
						Summary: "Auto-generated from request to /foo",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := RequestSniffer{
				Functions:     tt.functions,
				HostName:      "test-host",
				Namespace:     "test-namespace",
				SecurityModes: tt.securityModes,
			}

			got, gotErr := s.sniff(tt.r)

			if gotErr != nil {
				if !tt.wantErr {
					t.Errorf("sniff() failed: %v", gotErr)
				}
				return
			}
			if tt.wantErr {
				t.Fatal("sniff() succeeded unexpectedly")
			}
			assert.Equal(t, tt.want, got)
		})
	}
}
