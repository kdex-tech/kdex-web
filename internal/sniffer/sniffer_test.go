package sniffer

import (
	"io"
	"net/http/httptest"
	"strings"
	"testing"

	openapi "github.com/getkin/kin-openapi/openapi3"
	"github.com/go-logr/logr"
	"github.com/stretchr/testify/assert"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kdexv1alpha1 "kdex.dev/crds/api/v1alpha1"
	"kdex.dev/web/internal/host"
)

func TestRequestSniffer_calculatePath(t *testing.T) {
	tests := []struct {
		name        string
		method      string
		requestPath string
		patternPath string
		want        string
		wantErr     bool
	}{
		{
			name:        "get root",
			method:      "GET",
			requestPath: "/",
			want:        "/",
		},
		{
			name:        "get simple path",
			method:      "GET",
			requestPath: "/users",
			want:        "/users",
		},
		{
			name:        "get with pattern match",
			method:      "GET",
			requestPath: "/users/123",
			patternPath: "/users/{id}",
			want:        "/users/{id}",
		},
		{
			name:        "get with pattern mismatch path",
			method:      "GET",
			requestPath: "/admins/123",
			patternPath: "/users/{id}",
			wantErr:     true,
		},
		{
			name:        "get with wildcard pattern",
			method:      "GET",
			requestPath: "/static/css/main.css",
			patternPath: "/static/{path...}",
			want:        "/static/{path...}",
		},
		{
			name:        "error: pattern with method",
			method:      "GET",
			requestPath: "/users/123",
			patternPath: "GET /users/{id}",
			wantErr:     true,
		},
		{
			name:        "error: pattern without leading slash",
			method:      "GET",
			requestPath: "/users/123",
			patternPath: "users/{id}",
			wantErr:     true,
		},
		{
			name:        "invalid pattern format",
			method:      "GET",
			requestPath: "/users",
			patternPath: "/{",
			wantErr:     true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var s RequestSniffer
			r := httptest.NewRequest(tt.method, tt.requestPath, &io.PipeReader{})
			got, gotErr := s.calculatePath(r, tt.patternPath)
			if tt.wantErr {
				assert.Error(t, gotErr)
				return
			}
			assert.NoError(t, gotErr)
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestRequestSniffer_generateName(t *testing.T) {
	tests := []struct {
		name       string
		path       string
		headerName string
		existing   *kdexv1alpha1.KDexFunction
		want       string
	}{
		{
			name: "from simple path",
			path: "/users",
			want: "gen-users",
		},
		{
			name: "from nested path",
			path: "/api/v1/users",
			want: "gen-api-v1-users",
		},
		{
			name: "from pattern path",
			path: "/users/{id}",
			want: "gen-users-id",
		},
		{
			name: "from wildcard pattern",
			path: "/static/{path...}",
			want: "gen-static-path",
		},
		{
			name:       "from header name",
			path:       "/users",
			headerName: "custom-name",
			want:       "custom-name",
		},
		{
			name: "from existing name",
			path: "/users",
			existing: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{Name: "existing-name"},
			},
			want: "existing-name",
		},
		{
			name: "root path",
			path: "/",
			want: "gen-root",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := &RequestSniffer{}
			got := s.generateName(tt.path, tt.existing, tt.headerName)
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestRequestSniffer_matchExisting(t *testing.T) {
	items := []kdexv1alpha1.KDexFunction{
		{
			ObjectMeta: metav1.ObjectMeta{Name: "fn1"},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				API: kdexv1alpha1.KDexOpenAPI{
					Path: "/users",
					KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
						Get: &openapi.Operation{},
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{AutoGenerated: true},
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{Name: "fn2"},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				API: kdexv1alpha1.KDexOpenAPI{
					Path: "/posts",
					KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
						Post: &openapi.Operation{},
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{AutoGenerated: false},
			},
		},
	}

	tests := []struct {
		name                 string
		path                 string
		method               string
		wantExistingName     string
		wantExactMethodMatch bool
	}{
		{
			name:                 "exact match autogenerated",
			path:                 "/users",
			method:               "GET",
			wantExistingName:     "fn1",
			wantExactMethodMatch: true,
		},
		{
			name:                 "exact match manual",
			path:                 "/posts",
			method:               "POST",
			wantExistingName:     "fn2",
			wantExactMethodMatch: true,
		},
		{
			name:                 "path match but new method",
			path:                 "/users",
			method:               "POST",
			wantExistingName:     "fn1",
			wantExactMethodMatch: false,
		},
		{
			name:                 "no match",
			path:                 "/unknown",
			method:               "GET",
			wantExistingName:     "",
			wantExactMethodMatch: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := &RequestSniffer{}
			gotExisting, gotExact := s.matchExisting(items, tt.path, tt.method)
			if tt.wantExistingName == "" {
				assert.Nil(t, gotExisting)
			} else {
				assert.NotNil(t, gotExisting)
				assert.Equal(t, tt.wantExistingName, gotExisting.Name)
			}
			assert.Equal(t, tt.wantExactMethodMatch, gotExact)
		})
	}
}

func TestRequestSniffer_mergeFunction(t *testing.T) {
	s := &RequestSniffer{HostName: "test-host"}

	t.Run("new function", func(t *testing.T) {
		fn := &kdexv1alpha1.KDexFunction{}
		api := kdexv1alpha1.KDexOpenAPIInternal{
			Get: &openapi.Operation{Summary: "Get It"},
		}
		s.mergeFunction(fn, api, "/test", nil)

		assert.True(t, fn.Spec.Metadata.AutoGenerated)
		assert.Equal(t, "/test", fn.Spec.API.Path)
		assert.NotNil(t, fn.Spec.API.Get)
		assert.Equal(t, "test-host", fn.Spec.HostRef.Name)
		assert.Equal(t, "go", fn.Spec.Function.Language)
	})

	t.Run("merge new method into existing", func(t *testing.T) {
		existingFn := &kdexv1alpha1.KDexFunction{
			Spec: kdexv1alpha1.KDexFunctionSpec{
				API: kdexv1alpha1.KDexOpenAPI{
					Path: "/test",
					KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
						Get: &openapi.Operation{Summary: "Old Get"},
					},
				},
				HostRef: v1.LocalObjectReference{Name: "test-host"},
			},
		}

		fn := &kdexv1alpha1.KDexFunction{}
		// Simulate CreateOrUpdate behavior where fn starts empty but then we merge
		api := kdexv1alpha1.KDexOpenAPIInternal{
			Post: &openapi.Operation{Summary: "New Post"},
		}

		// In Sniff, we pass 'existing' which is used to populate fn.Spec if it's a new create
		// Here we simulate the first call to mergeFunction on a "new" fn that should inherit from existing
		s.mergeFunction(fn, api, "/test", existingFn)

		assert.NotNil(t, fn.Spec.API.Get)
		assert.NotNil(t, fn.Spec.API.Post)
		assert.Equal(t, "Old Get", fn.Spec.API.Get.Summary)
		assert.Equal(t, "New Post", fn.Spec.API.Post.Summary)
	})
}

func TestRequestSniffer_parseRequestIntoAPI(t *testing.T) {
	hh := host.NewHostHandler("test", "test", logr.Discard())
	// Set a mock host so SecurityModes returns something
	hh.SetHost(&kdexv1alpha1.KDexHostSpec{}, nil, nil, nil, "", map[string]host.PathInfo{})

	s := &RequestSniffer{HostHandler: hh}

	t.Run("detect auth", func(t *testing.T) {
		r := httptest.NewRequest("GET", "/test", nil)
		r.Header.Set("Authorization", "Bearer token")

		api := s.parseRequestIntoAPI(r, "GET", "/test")

		assert.NotNil(t, api.Get)
		assert.NotNil(t, api.Get.Security)
		assert.Len(t, *api.Get.Security, 1)
		assert.Contains(t, (*api.Get.Security)[0], "bearer")
	})

	t.Run("no auth", func(t *testing.T) {
		r := httptest.NewRequest("GET", "/test", nil)

		api := s.parseRequestIntoAPI(r, "GET", "/test")

		assert.NotNil(t, api.Get)
		assert.Nil(t, api.Get.Security)
	})

	t.Run("query array", func(t *testing.T) {
		r := httptest.NewRequest("GET", "/test?id=1&id=2", nil)
		api := s.parseRequestIntoAPI(r, "GET", "/test")

		found := false
		for _, p := range api.Parameters {
			if p.Name == "id" {
				assert.True(t, p.Schema.Value.Type.Is("array"))
				found = true
			}
		}
		assert.True(t, found)
	})

	t.Run("json schema inference", func(t *testing.T) {
		body := `{"name": "John", "age": 30, "active": true}`
		r := httptest.NewRequest("POST", "/test", strings.NewReader(body))
		r.Header.Set("Content-Type", "application/json")

		api := s.parseRequestIntoAPI(r, "POST", "/test")

		assert.NotNil(t, api.Post)
		assert.NotNil(t, api.Post.RequestBody)

		content := api.Post.RequestBody.Value.Content["application/json"]
		assert.NotNil(t, content)
		schema := content.Schema.Value
		assert.True(t, schema.Type.Is("object"))
		assert.NotNil(t, schema.Properties["name"])
		assert.True(t, schema.Properties["name"].Value.Type.Is("string"))
		assert.True(t, schema.Properties["age"].Value.Type.Is("number"))
		assert.True(t, schema.Properties["active"].Value.Type.Is("boolean"))
	})
}

func TestRequestSniffer_DocsHandler(t *testing.T) {
	s := &RequestSniffer{}
	w := httptest.NewRecorder()
	r := httptest.NewRequest("GET", "/~/sniffer/docs", nil)

	s.DocsHandler(w, r)

	assert.Equal(t, 200, w.Code)
	assert.Equal(t, "text/markdown", w.Header().Get("Content-Type"))
	assert.Contains(t, w.Body.String(), "# KDex Request Sniffer Documentation")
	assert.Contains(t, w.Body.String(), "X-KDex-Function-Name")
}
