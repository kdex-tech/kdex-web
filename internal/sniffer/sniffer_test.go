package sniffer

import (
	"bytes"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"net/textproto"
	"net/url"
	"strings"
	"testing"

	openapi "github.com/getkin/kin-openapi/openapi3"
	"github.com/stretchr/testify/assert"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	kdexv1alpha1 "kdex.dev/crds/api/v1alpha1"
	ko "kdex.dev/web/internal/openapi"
)

func TestRequestSniffer_calculatePath(t *testing.T) {
	tests := []struct {
		name        string
		method      string
		requestPath string
		patternPath string
		want        string
		wantErr     bool
	}{
		{
			name:        "get root",
			method:      "GET",
			requestPath: "/",
			want:        "/",
		},
		{
			name:        "get simple path",
			method:      "GET",
			requestPath: "/users",
			want:        "/users",
		},
		{
			name:        "get with pattern match",
			method:      "GET",
			requestPath: "/users/123",
			patternPath: "/users/{id}",
			want:        "/users/{id}",
		},
		{
			name:        "get with pattern mismatch path",
			method:      "GET",
			requestPath: "/admins/123",
			patternPath: "/users/{id}",
			wantErr:     true,
		},
		{
			name:        "get with wildcard pattern",
			method:      "GET",
			requestPath: "/static/css/main.css",
			patternPath: "/static/{path...}",
			want:        "/static/{path...}",
		},
		{
			name:        "error: pattern with method",
			method:      "GET",
			requestPath: "/users/123",
			patternPath: "GET /users/{id}",
			wantErr:     true,
		},
		{
			name:        "error: pattern without leading slash",
			method:      "GET",
			requestPath: "/users/123",
			patternPath: "users/{id}",
			wantErr:     true,
		},
		{
			name:        "invalid pattern format",
			method:      "GET",
			requestPath: "/users",
			patternPath: "/{",
			wantErr:     true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var s RequestSniffer
			r := httptest.NewRequest(tt.method, tt.requestPath, &io.PipeReader{})
			got, gotErr := s.calculatePath(r, tt.patternPath)
			if tt.wantErr {
				assert.Error(t, gotErr)
				return
			}
			assert.NoError(t, gotErr)
			assert.Equal(t, tt.want, got)
		})
	}
}

func raw(it any) *runtime.RawExtension {
	var raw []byte
	switch v := it.(type) {
	case *openapi.Operation:
		raw, _ = v.MarshalJSON()
	case openapi.Operation:
		raw, _ = v.MarshalJSON()
	case *openapi.Parameter:
		raw, _ = v.MarshalJSON()
	case openapi.Parameter:
		raw, _ = v.MarshalJSON()
	case *openapi.Schema:
		raw, _ = v.MarshalJSON()
	case openapi.Schema:
		raw, _ = v.MarshalJSON()
	}

	return &runtime.RawExtension{
		Raw: raw,
	}
}

func rawA(it any) []runtime.RawExtension {
	out := []runtime.RawExtension{}
	switch v := it.(type) {
	case []openapi.Parameter:
		for _, e := range v {
			out = append(out, *raw(e))
		}
	}
	return out
}

func rawM(it any) map[string]runtime.RawExtension {
	out := map[string]runtime.RawExtension{}
	switch v := it.(type) {
	case map[string]openapi.Schema:
		for k, v := range v {
			out[k] = *raw(v)
		}
	}
	return out
}

func TestRequestSniffer_matchExisting(t *testing.T) {
	items := []kdexv1alpha1.KDexFunction{
		{
			ObjectMeta: metav1.ObjectMeta{Name: "gen-users"},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				API: kdexv1alpha1.KDexOpenAPI{
					Path: "/users",
					KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
						Get: raw(&openapi.Operation{
							OperationID: "gen-users-get",
						}),
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{AutoGenerated: true},
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{Name: "gen-posts"},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				API: kdexv1alpha1.KDexOpenAPI{
					Path: "/posts",
					KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
						Post: raw(&openapi.Operation{
							OperationID: "gen-posts-post",
						}),
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{AutoGenerated: false},
			},
		},
	}

	tests := []struct {
		name                 string
		headerFunctionName   string
		headerOperationId    string
		path                 string
		method               string
		wantExistingName     string
		wantExactMethodMatch bool
	}{
		{
			name:                 "exact match autogenerated",
			path:                 "/users",
			method:               "GET",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: true,
		},
		{
			name:                 "exact match manual",
			path:                 "/posts",
			method:               "POST",
			wantExistingName:     "gen-posts",
			wantExactMethodMatch: true,
		},
		{
			name:                 "path match but new method",
			path:                 "/users",
			method:               "POST",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: false,
		},
		{
			name:                 "no match",
			path:                 "/unknown",
			method:               "GET",
			wantExistingName:     "",
			wantExactMethodMatch: false,
		},
		{
			name:                 "match by name header",
			path:                 "/unknown",
			method:               "GET",
			headerFunctionName:   "gen-users",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: false,
		},
		{
			name:                 "match by operation id header",
			path:                 "/users",
			method:               "GET",
			headerFunctionName:   "foo",
			headerOperationId:    "gen-users-get",
			wantExistingName:     "gen-users",
			wantExactMethodMatch: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			name := ko.GenerateNameFromPath(tt.path, tt.headerFunctionName)
			operationId := ko.GenerateOperationID(name, tt.method, tt.headerOperationId)

			s := &RequestSniffer{}
			gotExisting, gotExact := s.matchExisting(items, name, tt.path, tt.method, operationId)
			if tt.wantExistingName == "" {
				assert.Nil(t, gotExisting)
			} else {
				assert.NotNil(t, gotExisting)
				assert.Equal(t, tt.wantExistingName, gotExisting.Name)
			}
			assert.Equal(t, tt.wantExactMethodMatch, gotExact)
		})
	}
}

func TestRequestSniffer_inMatchesOut(t *testing.T) {
	tests := []struct {
		name       string
		in         any
		assertions func(t *testing.T, kdo *kdexv1alpha1.KDexOpenAPI, in any)
	}{
		{
			name: "operation equals through serialization",
			in: &openapi.Operation{
				Description: "Test",
			},
			assertions: func(t *testing.T, kdo *kdexv1alpha1.KDexOpenAPI, in any) {
				kdo.SetConnect(in.(*openapi.Operation))
				assert.Equal(t, in, kdo.GetConnect())
				assert.Contains(t, string(kdo.Connect.Raw), `"Test"`)
			},
		},
		{
			name: "schemas equals through serialization",
			in: map[string]openapi.Schema{
				"#/components/schemas/User": {
					Type: &openapi.Types{openapi.TypeString},
				},
			},
			assertions: func(t *testing.T, kdo *kdexv1alpha1.KDexOpenAPI, in any) {
				kdo.SetSchemas(in.(map[string]openapi.Schema))
				assert.Equal(t, in, kdo.GetSchemas())

				v, ok := kdo.Schemas["#/components/schemas/User"]
				assert.True(t, ok)
				assert.Contains(t, string(v.Raw), `"string"`)
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			kdo := &kdexv1alpha1.KDexOpenAPI{}
			tt.assertions(t, kdo, tt.in)
		})
	}
}

func TestRequestSniffer_mergeAPIIntoFunction(t *testing.T) {
	s := &RequestSniffer{HostName: "test-host"}

	tests := []struct {
		name          string
		out           *kdexv1alpha1.KDexFunction
		path          string
		method        string
		op            *openapi.Operation
		schemas       map[string]openapi.Schema
		keepConflicts bool
		assertions    func(t *testing.T, fn *kdexv1alpha1.KDexFunction)
	}{
		{
			name:       "no op",
			out:        &kdexv1alpha1.KDexFunction{},
			op:         &openapi.Operation{},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {},
		},
		{
			name:   "add connect",
			out:    &kdexv1alpha1.KDexFunction{},
			method: "CONNECT",
			op: &openapi.Operation{
				Description: "CONNECT /path",
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Contains(t, "CONNECT /path", fn.Spec.API.GetConnect().Description)
			},
		},
		{
			name:   "add delete",
			out:    &kdexv1alpha1.KDexFunction{},
			method: "DELETE",
			op: &openapi.Operation{
				Description: "DELETE /path",
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Contains(t, "DELETE /path", fn.Spec.API.GetDelete().Description)
			},
		},
		{
			name:   "add head",
			out:    &kdexv1alpha1.KDexFunction{},
			method: "HEAD",
			op: &openapi.Operation{
				Description: "HEAD /path",
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "HEAD /path", fn.Spec.API.GetHead().Description)
			},
		},
		{
			name:   "add options",
			out:    &kdexv1alpha1.KDexFunction{},
			method: "OPTIONS",
			op: &openapi.Operation{
				Description: "OPTIONS /path",
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "OPTIONS /path", fn.Spec.API.GetOptions().Description)
			},
		},
		{
			name:   "add patch",
			out:    &kdexv1alpha1.KDexFunction{},
			method: "PATCH",
			op: &openapi.Operation{
				Description: "PATCH /path",
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "PATCH /path", fn.Spec.API.GetPatch().Description)
			},
		},
		{
			name:   "add post",
			out:    &kdexv1alpha1.KDexFunction{},
			method: "POST",
			op: &openapi.Operation{
				Description: "POST /path",
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "POST /path", fn.Spec.API.GetPost().Description)
			},
		},
		{
			name:   "add put",
			out:    &kdexv1alpha1.KDexFunction{},
			method: "PUT",
			op: &openapi.Operation{
				Description: "PUT /path",
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "PUT /path", fn.Spec.API.GetPut().Description)
			},
		},
		{
			name:   "add trace",
			out:    &kdexv1alpha1.KDexFunction{},
			method: "TRACE",
			op: &openapi.Operation{
				Description: "TRACE /path",
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "TRACE /path", fn.Spec.API.GetTrace().Description)
			},
		},
		{
			name: "set path",
			out:  &kdexv1alpha1.KDexFunction{},
			path: "/foo",
			op:   &openapi.Operation{},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "/foo", fn.Spec.API.Path)
				assert.Equal(t, "Auto-generated from request to /foo", fn.Spec.API.Description)
			},
		},
		{
			name: "add new schema",
			out:  &kdexv1alpha1.KDexFunction{},
			op:   &openapi.Operation{},
			schemas: map[string]openapi.Schema{
				"User": {
					Type: &openapi.Types{openapi.TypeObject},
				},
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				schemas := fn.Spec.API.GetSchemas()

				s, ok := schemas["User"]
				assert.Equal(t, true, ok)
				assert.Equal(t, &openapi.Types{openapi.TypeObject}, s.Type)
			},
		},
		{
			name: "add conflicting schema",
			out: &kdexv1alpha1.KDexFunction{
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Schemas: rawM(map[string]openapi.Schema{
								"User": {
									Description: "Existing User",
									Type:        &openapi.Types{openapi.TypeObject},
								},
							}),
						},
					},
				},
			},
			op: &openapi.Operation{},
			schemas: map[string]openapi.Schema{
				"User": {
					Description: "Conflicting User",
					Type:        &openapi.Types{openapi.TypeObject},
				},
			},
			path:          "/foo",
			keepConflicts: true,
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				schemas := fn.Spec.API.GetSchemas()

				s, ok := schemas["User"]
				assert.Equal(t, true, ok)
				assert.Equal(t, "Existing User", s.Description)
				assert.Equal(t, 2, len(fn.Spec.API.Schemas))

				s2, ok := schemas["User:conflict:"+ko.GenerateNameFromPath(fn.Spec.API.Path, "")]
				assert.Equal(t, true, ok)
				assert.Equal(t, "Conflicting User", s2.Description)
			},
		},
		{
			name: "add trace to existing",
			out: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name: "gen-path",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						Path: "/path",
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Get: raw(&openapi.Operation{
								Description: "GET /path",
							}),
						},
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
				},
			},
			method: "TRACE",
			op: &openapi.Operation{
				Description: "TRACE /path",
			},
			assertions: func(t *testing.T, fn *kdexv1alpha1.KDexFunction) {
				assert.Equal(t, "GET /path", fn.Spec.API.GetGet().Description)
				assert.Equal(t, "TRACE /path", fn.Spec.API.GetTrace().Description)
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s.mergeAPIIntoFunction(tt.out, tt.path, tt.method, tt.op, tt.schemas, tt.keepConflicts)
			tt.assertions(t, tt.out)
		})
	}
}

func TestRequestSniffer_parseRequestIntoAPI(t *testing.T) {
	s := &RequestSniffer{
		SecurityModes: []string{"bearer"},
	}

	tests := []struct {
		name       string
		r          *http.Request
		assertions func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error)
		skip       bool
	}{
		{
			name: "GET /foo",
			r:    httptest.NewRequest("GET", "/foo", http.NoBody),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "gen-foo-get", op.OperationID)
				assert.Nil(t, op.Security)
			},
		},
		{
			name: "GET /foo with tags",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("X-KDex-Function-Tags", "one,two,three")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "gen-foo-get", op.OperationID)
				assert.Equal(t, []string{"one", "two", "three"}, op.Tags)
			},
		},
		{
			name: "GET /foo with description and summary",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("X-KDex-Function-Description", "custom description")
				r.Header.Add("X-KDex-Function-Summary", "custom summary")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "gen-foo-get", op.OperationID)
				assert.Equal(t, "custom description", op.Description)
				assert.Equal(t, "custom summary", op.Summary)
			},
		},
		{
			name: "GET /foo without Accept: produces default schemaless response",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "gen-foo-get", op.OperationID)
				assert.Equal(t, 1, op.Responses.Len())
				resp := op.Responses.Value("200")
				assert.NotNil(t, resp)
				assert.Equal(t, openapi.Ptr("Successful response"), resp.Value.Description)
				assert.Equal(t, 0, len(resp.Value.Content))
			},
		},
		{
			name: "GET /foo with Accept: *\\* produces schemaless response",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("Accept", "*/*")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "gen-foo-get", op.OperationID)
				assert.Equal(t, 1, op.Responses.Len())
				resp := op.Responses.Value("200")
				assert.NotNil(t, resp)
				assert.Equal(t, openapi.Ptr("Successful response"), resp.Value.Description)
				assert.Equal(t, 0, len(resp.Value.Content))
			},
		},
		{
			name: "GET /foo with specific Accept: produces schema response",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("Accept", "application/json")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "gen-foo-get", op.OperationID)
				assert.Equal(t, 1, op.Responses.Len())
				resp := op.Responses.Value("200")
				assert.NotNil(t, resp)
				assert.Equal(t, openapi.Ptr("Successful response"), resp.Value.Description)
				assert.Equal(t, 1, len(resp.Value.Content))
				assert.NotNil(t, resp.Value.Content.Get("application/json").Schema)
				assert.Nil(t, resp.Value.Content.Get("application/json").Schema.Value.Type)
			},
		},
		{
			name: "GET /foo with specific Accept: and set X-KDex-Function-Response-Schema-Ref",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Add("Accept", "application/json")
				r.Header.Add("X-KDex-Function-Response-Schema-Ref", "Foo")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "gen-foo-get", op.OperationID)
				assert.Equal(t, 1, op.Responses.Len())
				resp := op.Responses.Value("200")
				assert.NotNil(t, resp)
				assert.Equal(t, openapi.Ptr("Successful response"), resp.Value.Description)
				assert.Equal(t, 1, len(resp.Value.Content))
				assert.NotNil(t, resp.Value.Content.Get("application/json").Schema)
				assert.Equal(t, "#/components/schemas/Foo", resp.Value.Content.Get("application/json").Schema.Ref)
			},
		},
		{
			name: "detect auth",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/foo", http.NoBody)
				r.Header.Set("Authorization", "Bearer token")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "gen-foo-get", op.OperationID)
				assert.NotNil(t, op.Security)
				assert.Len(t, *op.Security, 1)
				assert.Contains(t, (*op.Security)[0], "bearer")
			},
		},
		{
			name: "query array",
			r:    httptest.NewRequest("GET", "/test?id=1&id=2", http.NoBody),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "gen-test-get", op.OperationID)
				found := false
				for _, p := range op.Parameters {
					if p.Value.Name == "id" {
						assert.True(t, p.Value.Schema.Value.Type.Is("array"))
						found = true
					}
				}
				assert.True(t, found)
			},
		},
		{
			name: "json schema inference",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", strings.NewReader(`
{
	"name": "John",
	"age": 30,
	"active": true,
	"tags": [
		"ai",
		"google"
	],
	"address": {
		"line1": "123 The Road",
		"Country": "BQ"
	}
}`))
				r.Header.Set("Content-Type", "application/json")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				expected := openapi.Schema{
					Description: "[KDex Sniffer] inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"name": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"age": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeNumber},
							},
						},
						"active": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeBoolean},
							},
						},
						"tags": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
						"address": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeObject},
								Properties: openapi.Schemas{
									"line1": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
									"Country": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
								},
							},
						},
					},
				}

				assert.NotNil(t, op)
				assert.NotNil(t, op.RequestBody)
				content := op.RequestBody.Value.Content["application/json"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect json schema and do inference",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", strings.NewReader(`
{
	"name": "John",
	"age": 30,
	"active": true,
	"tags": [
		"ai",
		"google"
	],
	"address": {
		"line1": "123 The Road",
		"Country": "BQ"
	}
}`))
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				expected := openapi.Schema{
					Description: "[KDex Sniffer] inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"name": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"age": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeNumber},
							},
						},
						"active": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeBoolean},
							},
						},
						"tags": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
						"address": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeObject},
								Properties: openapi.Schemas{
									"line1": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
									"Country": &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
								},
							},
						},
					},
				}

				assert.NotNil(t, op)
				assert.NotNil(t, op.RequestBody)
				content := op.RequestBody.Value.Content["application/json"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect application\\octet-stream",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", bytes.NewReader([]byte{123, 23, 34, 145, 233}))
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				expected := openapi.Schema{
					Description: "[KDex Sniffer] inferred from request body",
					Type:        &openapi.Types{openapi.TypeString},
					Format:      "binary",
				}

				assert.NotNil(t, op)
				assert.NotNil(t, op.RequestBody)
				content := op.RequestBody.Value.Content["application/octet-stream"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect application\\x-www-form-urlencoded and schema",
			r: func() *http.Request {
				data := url.Values{}
				data.Set("name", "John Doe")
				data.Set("email", "john@example.com")
				data.Set("occupation", "Software Engineer")
				encodedData := data.Encode()
				r := httptest.NewRequest("POST", "/test", strings.NewReader(encodedData))
				r.Header.Set("Content-Type", "application/x-www-form-urlencoded")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				expected := openapi.Schema{
					Description: "[KDex Sniffer] inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"name": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"email": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"occupation": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
					},
				}

				assert.NotNil(t, op)
				assert.NotNil(t, op.RequestBody)
				content := op.RequestBody.Value.Content["application/x-www-form-urlencoded"]
				assert.NotNil(t, content)
				assert.Equal(t, &expected, content.Schema.Value)
			},
		},
		{
			name: "auto detect mutlipart\\form-data and schema",
			r: func() *http.Request {
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)
				_ = writer.WriteField("username", "gopher_fan")
				_ = writer.WriteField("type", "admin")
				part, _ := writer.CreateFormFile("profile_pic", "image.svg")
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))
				writer.Close()
				r := httptest.NewRequest("POST", "/test", body)
				r.Header.Set("Content-Type", writer.FormDataContentType())
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				expectedSchema := openapi.Schema{
					Description: "[KDex Sniffer] inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"username": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"type": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"profile_pic": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Format: "binary",
								Type:   &openapi.Types{openapi.TypeString},
							},
						},
					},
				}
				expectedEncoding := map[string]*openapi.Encoding{
					"profile_pic": {
						ContentType: "image/svg+xml",
					},
				}

				assert.NotNil(t, op)
				assert.NotNil(t, op.RequestBody)
				content := op.RequestBody.Value.Content["multipart/form-data"]
				assert.NotNil(t, content)
				assert.Equal(t, &expectedSchema, content.Schema.Value)
				assert.Equal(t, expectedEncoding, content.Encoding)
			},
		},
		{
			name: "mutlipart\\form-data with content type and schema",
			r: func() *http.Request {
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)
				_ = writer.WriteField("username", "gopher_fan")
				h := make(textproto.MIMEHeader)
				h.Set("Content-Disposition", `form-data; name="profile_pic"; filename="image.svg"`)
				h.Set("Content-Type", "image/svg+xml")
				part, _ := writer.CreatePart(h)
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))
				writer.Close()
				r := httptest.NewRequest("POST", "/test", body)
				r.Header.Set("Content-Type", writer.FormDataContentType())
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				expectedSchema := openapi.Schema{
					Description: "[KDex Sniffer] inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"username": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeString},
							},
						},
						"profile_pic": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Format: "binary",
								Type:   &openapi.Types{openapi.TypeString},
							},
						},
					},
				}
				expectedEncoding := map[string]*openapi.Encoding{
					"profile_pic": {
						ContentType: "image/svg+xml",
					},
				}

				assert.NotNil(t, op)
				assert.NotNil(t, op.RequestBody)
				content := op.RequestBody.Value.Content["multipart/form-data"]
				assert.NotNil(t, content)
				assert.Equal(t, &expectedSchema, content.Schema.Value)
				assert.Equal(t, expectedEncoding, content.Encoding)
			},
		},
		{
			name: "mutlipart\\form-data with content type, arrays schema",
			r: func() *http.Request {
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)
				_ = writer.WriteField("username", "gopher_fan")
				_ = writer.WriteField("username", "bear_dude")

				// array file 1
				h := make(textproto.MIMEHeader)
				h.Set("Content-Disposition", `form-data; name="profile_pic"; filename="one.svg"`)
				h.Set("Content-Type", "image/svg+xml")
				part, _ := writer.CreatePart(h)
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))

				// array file 2
				h = make(textproto.MIMEHeader)
				h.Set("Content-Disposition", `form-data; name="profile_pic"; filename="two.svg"`)
				h.Set("Content-Type", "image/svg+xml")
				part, _ = writer.CreatePart(h)
				part.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><text y="15">A</text></svg>`))

				writer.Close()
				r := httptest.NewRequest("POST", "/test", body)
				r.Header.Set("Content-Type", writer.FormDataContentType())
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				expectedSchema := openapi.Schema{
					Description: "[KDex Sniffer] inferred from request body",
					Type:        &openapi.Types{openapi.TypeObject},
					Properties: openapi.Schemas{
						"username": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
						"profile_pic": &openapi.SchemaRef{
							Value: &openapi.Schema{
								Type: &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type:   &openapi.Types{openapi.TypeString},
										Format: "binary",
									},
								},
							},
						},
					},
				}
				expectedEncoding := map[string]*openapi.Encoding{
					"profile_pic": {
						ContentType: "image/svg+xml",
					},
				}

				assert.NotNil(t, op)
				assert.NotNil(t, op.RequestBody)
				content := op.RequestBody.Value.Content["multipart/form-data"]
				assert.NotNil(t, content)
				assert.Equal(t, &expectedSchema, content.Schema.Value)
				assert.Equal(t, expectedEncoding, content.Encoding)
			},
		},
		{
			name: "override response schema",
			r: func() *http.Request {
				r := httptest.NewRequest("POST", "/test", strings.NewReader(`{}`))
				r.Header.Set("X-KDex-Function-Request-Schema-Ref", "Foo")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.NotNil(t, op.RequestBody)
				content := op.RequestBody.Value.Content["application/json"]
				assert.NotNil(t, content)
				assert.Equal(t, "#/components/schemas/Foo", content.Schema.Ref)
				sharedSchema := schemas["#/components/schemas/Foo"]
				assert.NotNil(t, sharedSchema)
			},
		},
		{
			name: "external request schema override",
			r: func() *http.Request {
				r := httptest.NewRequest("PATCH", "/test", strings.NewReader(`[{"op": "replace", "path": "/email", "value": "john@fix.buz"}]`))
				r.Header.Set("X-KDex-Function-Request-Schema-Ref", "https://json.schemastore.org/json-patch")
				r.Header.Set("Content-Type", "application/json-patch+json")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.NotNil(t, op.RequestBody)
				content := op.RequestBody.Value.Content["application/json-patch+json"]
				assert.NotNil(t, content)
				assert.Equal(t, "https://json.schemastore.org/json-patch", content.Schema.Ref)
				assert.Equal(t, 0, len(schemas))
			},
		},
		{
			name: "external response schema override",
			r: func() *http.Request {
				r := httptest.NewRequest("GET", "/test", http.NoBody)
				r.Header.Set("X-KDex-Function-Response-Schema-Ref", "https://json.schemastore.org/json-patch")
				r.Header.Set("Accept", "application/json-patch+json")
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				resp := op.Responses.Value("200")
				assert.NotNil(t, resp)
				content := resp.Value.Content["application/json-patch+json"]
				assert.NotNil(t, content)
				assert.Equal(t, "https://json.schemastore.org/json-patch", content.Schema.Ref)
				assert.Equal(t, 0, len(schemas))
			},
		},
		{
			name: "CONNECT /test",
			r: func() *http.Request {
				r := httptest.NewRequest("CONNECT", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "CONNECT /test", op.Description)
			},
		},
		{
			name: "DELETE /test",
			r: func() *http.Request {
				r := httptest.NewRequest("DELETE", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "DELETE /test", op.Description)
			},
		},
		{
			name: "HEAD /test",
			r: func() *http.Request {
				r := httptest.NewRequest("HEAD", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "HEAD /test", op.Description)
			},
		},
		{
			name: "OPTIONS /test",
			r: func() *http.Request {
				r := httptest.NewRequest("OPTIONS", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "OPTIONS /test", op.Description)
			},
		},
		{
			name: "PATCH /test",
			r: func() *http.Request {
				r := httptest.NewRequest("PATCH", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "PATCH /test", op.Description)
			},
		},
		{
			name: "PUT /test",
			r: func() *http.Request {
				r := httptest.NewRequest("PUT", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "PUT /test", op.Description)
			},
		},
		{
			name: "TRACE /test",
			r: func() *http.Request {
				r := httptest.NewRequest("TRACE", "/test", http.NoBody)
				return r
			}(),
			assertions: func(t *testing.T, op *openapi.Operation, schemas map[string]openapi.Schema, err error) {
				assert.NotNil(t, op)
				assert.Equal(t, "TRACE /test", op.Description)
			},
		},
	}
	for _, tt := range tests {
		if tt.skip {
			return
		}
		t.Run(tt.name, func(t *testing.T) {
			name := ko.GenerateNameFromPath(tt.r.URL.Path, tt.r.Header.Get("X-KDex-Function-Name"))
			operationId := ko.GenerateOperationID(name, tt.r.Method, tt.r.Header.Get("X-KDex-Function-Operation-ID"))
			op, schemas, err := s.parseRequestIntoAPI(
				tt.r,
				ko.GenerateNameFromPath(tt.r.URL.Path, ""),
				tt.r.Method,
				tt.r.URL.Path,
				operationId)
			tt.assertions(t, op, schemas, err)
		})
	}
}

func TestRequestSniffer_parseRequestIntoAPI_and_mergeAPIIntoFunction(t *testing.T) {
	fn := &kdexv1alpha1.KDexFunction{}

	s := &RequestSniffer{}

	// start by defining a shared schema using PUT, Accept and schema ref headers

	r := httptest.NewRequest("PUT", "/users/{id}", strings.NewReader(`{"name": "John","email": "john@foo.bar"}`))
	r.Header.Set("Accept", "application/json")
	r.Header.Set("X-KDex-Function-Request-Schema-Ref", "User")
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	name := ko.GenerateNameFromPath(r.URL.Path, "")
	operationId := ko.GenerateOperationID(name, r.Method, "")
	op, schemas, err := s.parseRequestIntoAPI(
		r,
		ko.GenerateNameFromPath(r.URL.Path, ""),
		r.Method,
		r.URL.Path,
		operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, "/users/{id}", r.Method, op, schemas, false)

	expected := &kdexv1alpha1.KDexFunction{
		Spec: kdexv1alpha1.KDexFunctionSpec{
			API: kdexv1alpha1.KDexOpenAPI{
				Description: "Auto-generated from request to /users/{id}",
				Path:        "/users/{id}",
				KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
					Put: raw(&openapi.Operation{
						Description: "PUT /users/{id}",
						OperationID: "gen-users-id-put",
						Parameters: openapi.Parameters{
							&openapi.ParameterRef{
								Value: &openapi.Parameter{
									Description: "Path parameter: id",
									Name:        "id",
									In:          "path",
									Required:    true,
									Schema: &openapi.SchemaRef{
										Value: &openapi.Schema{
											Type: &openapi.Types{openapi.TypeString},
										},
									},
								},
							},
						},
						RequestBody: &openapi.RequestBodyRef{
							Value: &openapi.RequestBody{
								Content: openapi.Content{
									"application/json": &openapi.MediaType{
										Schema: &openapi.SchemaRef{
											Ref: "#/components/schemas/User",
										},
									},
								},
								Description: "[KDex Sniffer] inferred from request body",
							},
						},
						Responses: openapi.NewResponses(
							openapi.WithStatus(200, &openapi.ResponseRef{
								Value: &openapi.Response{
									Description: openapi.Ptr("Successful response"),
									Content: openapi.Content{
										"application/json": &openapi.MediaType{
											Schema: &openapi.SchemaRef{
												Ref: "#/components/schemas/User",
											},
										},
									},
								},
							}),
						),
						Summary: "gen-users-id",
					}),
					Schemas: rawM(map[string]openapi.Schema{
						"User": {
							Description: "[KDex Sniffer] inferred from request body",
							Type:        &openapi.Types{openapi.TypeObject},
							Properties: openapi.Schemas{
								"email": &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
								"name": &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeString},
									},
								},
							},
						},
					}),
				},
			},
			Metadata: kdexv1alpha1.KDexFunctionMetadata{
				AutoGenerated: true,
			},
			Function: kdexv1alpha1.KDexFunctionExec{
				Language:    "go",
				Environment: "go-env",
			},
		},
	}

	assert.Equal(t, expected, fn)

	// now add GET, Accept and schema ref header

	r = httptest.NewRequest("GET", "/users/{id}", http.NoBody)
	r.Header.Set("Accept", "application/json")
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	name = ko.GenerateNameFromPath(r.URL.Path, "")
	operationId = ko.GenerateOperationID(name, r.Method, "")
	op, schemas, err = s.parseRequestIntoAPI(
		r,
		ko.GenerateNameFromPath(r.URL.Path, ""),
		r.Method,
		r.URL.Path,
		operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, "/users/{id}", r.Method, op, schemas, false)

	expected.Spec.API.Get = raw(&openapi.Operation{
		Description: "GET /users/{id}",
		OperationID: "gen-users-id-get",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithStatus(200, &openapi.ResponseRef{
				Value: &openapi.Response{
					Description: openapi.Ptr("Successful response"),
					Content: openapi.Content{
						"application/json": &openapi.MediaType{
							Schema: &openapi.SchemaRef{
								Ref: "#/components/schemas/User",
							},
						},
					},
				},
			}),
		),
		Summary: "gen-users-id",
	})

	assert.Equal(t, expected, fn)

	// now add DELETE, Accept and schema ref header

	r = httptest.NewRequest("DELETE", "/users/{id}", http.NoBody)
	r.Header.Set("Accept", "application/json")
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	name = ko.GenerateNameFromPath(r.URL.Path, "")
	operationId = ko.GenerateOperationID(name, r.Method, "")
	op, schemas, err = s.parseRequestIntoAPI(
		r,
		ko.GenerateNameFromPath(r.URL.Path, ""),
		r.Method,
		r.URL.Path,
		operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, "/users/{id}", r.Method, op, schemas, false)

	expected.Spec.API.Delete = raw(&openapi.Operation{
		Description: "DELETE /users/{id}",
		OperationID: "gen-users-id-delete",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithStatus(200, &openapi.ResponseRef{
				Value: &openapi.Response{
					Description: openapi.Ptr("Successful response"),
					Content: openapi.Content{
						"application/json": &openapi.MediaType{
							Schema: &openapi.SchemaRef{
								Ref: "#/components/schemas/User",
							},
						},
					},
				},
			}),
		),
		Summary: "gen-users-id",
	})

	assert.Equal(t, expected, fn)

	// now add HEAD (existence check)

	r = httptest.NewRequest("HEAD", "/users/{id}", http.NoBody)

	name = ko.GenerateNameFromPath(r.URL.Path, "")
	operationId = ko.GenerateOperationID(name, r.Method, "")
	op, schemas, err = s.parseRequestIntoAPI(
		r,
		ko.GenerateNameFromPath(r.URL.Path, ""),
		r.Method,
		r.URL.Path,
		operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, "/users/{id}", r.Method, op, schemas, false)

	expected.Spec.API.Head = raw(&openapi.Operation{
		Description: "HEAD /users/{id}",
		OperationID: "gen-users-id-head",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithStatus(200, &openapi.ResponseRef{
				Value: &openapi.Response{
					Description: openapi.Ptr("Successful response"),
				},
			}),
		),
		Summary: "gen-users-id",
	})

	assert.Equal(t, expected, fn)

	// now add PATCH, Accept and schema ref headers

	r = httptest.NewRequest("PATCH", "/users/{id}", strings.NewReader(`[{"op": "replace", "path": "/email", "value": "john@fix.buz"}]`))
	r.Header.Set("Accept", "application/json")
	r.Header.Set("Content-Type", "application/json-patch+json")
	r.Header.Set("X-KDex-Function-Response-Schema-Ref", "User")

	name = ko.GenerateNameFromPath(r.URL.Path, "")
	operationId = ko.GenerateOperationID(name, r.Method, "")
	op, schemas, err = s.parseRequestIntoAPI(
		r,
		ko.GenerateNameFromPath(r.URL.Path, ""),
		r.Method,
		r.URL.Path,
		operationId)
	assert.NoError(t, err)
	s.mergeAPIIntoFunction(fn, "/users/{id}", r.Method, op, schemas, false)

	expected.Spec.API.Patch = raw(&openapi.Operation{
		Description: "PATCH /users/{id}",
		OperationID: "gen-users-id-patch",
		Parameters: openapi.Parameters{
			&openapi.ParameterRef{
				Value: &openapi.Parameter{
					Description: "Path parameter: id",
					Name:        "id",
					In:          "path",
					Required:    true,
					Schema: &openapi.SchemaRef{
						Value: &openapi.Schema{
							Type: &openapi.Types{openapi.TypeString},
						},
					},
				},
			},
		},
		RequestBody: &openapi.RequestBodyRef{
			Value: &openapi.RequestBody{
				Content: openapi.Content{
					"application/json-patch+json": &openapi.MediaType{
						Schema: &openapi.SchemaRef{
							Value: &openapi.Schema{
								Description: "[KDex Sniffer] inferred from request body",
								Type:        &openapi.Types{openapi.TypeArray},
								Items: &openapi.SchemaRef{
									Value: &openapi.Schema{
										Type: &openapi.Types{openapi.TypeObject},
										Properties: openapi.Schemas{
											"op": &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
											"path": &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
											"value": &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				Description: "[KDex Sniffer] inferred from request body",
			},
		},
		Responses: openapi.NewResponses(
			openapi.WithStatus(200, &openapi.ResponseRef{
				Value: &openapi.Response{
					Description: openapi.Ptr("Successful response"),
					Content: openapi.Content{
						"application/json": &openapi.MediaType{
							Schema: &openapi.SchemaRef{
								Ref: "#/components/schemas/User",
							},
						},
					},
				},
			}),
		),
		Summary: "gen-users-id",
	})

	assert.Equal(t, expected, fn)
}

func TestRequestSniffer_DocsHandler(t *testing.T) {
	s := &RequestSniffer{}
	w := httptest.NewRecorder()
	r := httptest.NewRequest("GET", "/~/sniffer/docs", nil)

	s.DocsHandler(w, r)

	assert.Equal(t, 200, w.Code)
	assert.Equal(t, "text/markdown", w.Header().Get("Content-Type"))
	assert.Contains(t, w.Body.String(), "# KDex Request Sniffer Documentation")
	assert.Contains(t, w.Body.String(), "X-KDex-Function-Name")
}

func TestRequestSniffer_sniff(t *testing.T) {
	tests := []struct {
		name          string
		r             *http.Request
		functions     []kdexv1alpha1.KDexFunction
		securityModes []string
		want          *kdexv1alpha1.KDexFunction
		wantErr       bool
	}{
		{
			name: "GET /~/internal",
			r:    httptest.NewRequest("GET", "/~/internal", http.NoBody),
			want: nil,
		},
		{
			name: "GET /foo",
			r:    httptest.NewRequest("GET", "/foo", http.NoBody),
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						Description: "Auto-generated from request to /foo",
						Path:        "/foo",
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Get: raw(&openapi.Operation{
								Description: "GET /foo",
								OperationID: "gen-foo-get",
								Responses: openapi.NewResponses(
									openapi.WithStatus(200, &openapi.ResponseRef{
										Value: &openapi.Response{
											Description: openapi.Ptr("Successful response"),
										},
									}),
								),
								Summary: "gen-foo",
							}),
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
				},
			},
		},
		{
			name: "GET /foo with bad X-KDex-Function-Pattern-Path",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/foo", http.NoBody)
				it.Header.Set("X-KDex-Function-Pattern-Path", "/bar")
				return it
			}(),
			wantErr: true,
		},
		{
			name: "GET /foo existing is not autogenerated",
			r:    httptest.NewRequest("GET", "/foo", http.NoBody),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.KDexOpenAPI{
							Path: "/foo",
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: false,
						},
					},
				},
			},
			wantErr: true,
		},
		{
			name: "GET /foo with X-KDex-Function-Pattern-Path",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/foo", http.NoBody)
				it.Header.Set("X-KDex-Function-Pattern-Path", "/{bar}")
				return it
			}(),
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-bar",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						Description: "Auto-generated from request to /{bar}",
						Path:        "/{bar}",
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Get: raw(&openapi.Operation{
								Description: "GET /{bar}",
								OperationID: "gen-bar-get",
								Parameters: openapi.Parameters{
									&openapi.ParameterRef{
										Value: &openapi.Parameter{
											Description: "Path parameter: bar",
											In:          "path",
											Name:        "bar",
											Required:    true,
											Schema: &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
										},
									},
								},
								Responses: openapi.NewResponses(
									openapi.WithStatus(200, &openapi.ResponseRef{
										Value: &openapi.Response{
											Description: openapi.Ptr("Successful response"),
										},
									}),
								),
								Summary: "gen-bar",
							}),
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
				},
			},
		},
		{
			name: "modify existing function by adding operation",
			r:    httptest.NewRequest("GET", "/foo", http.NoBody),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.KDexOpenAPI{
							Path: "/foo",
							KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
								Put: raw(&openapi.Operation{
									Description: "PUT /foo",
									OperationID: "gen-foo-put",
								}),
							},
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: true,
						},
					},
				},
			},
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						Description: "Auto-generated from request to /foo",
						Path:        "/foo",
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Get: raw(&openapi.Operation{
								Description: "GET /foo",
								OperationID: "gen-foo-get",
								Responses: openapi.NewResponses(
									openapi.WithStatus(200, &openapi.ResponseRef{
										Value: &openapi.Response{
											Description: openapi.Ptr("Successful response"),
										},
									}),
								),
								Summary: "gen-foo",
							}),
							Put: raw(&openapi.Operation{
								Description: "PUT /foo",
								OperationID: "gen-foo-put",
							}),
						},
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
				},
			},
		},
		{
			name: "does not modify operation without X-KDex-Function-Overwrite-Operation: true",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/foo?foo=bar", http.NoBody)
				return it
			}(),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.KDexOpenAPI{
							Path: "/foo",
							KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
								Get: raw(&openapi.Operation{
									Description: "GET /foo",
									OperationID: "gen-foo-get",
								}),
							},
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: true,
						},
					},
				},
			},
			wantErr: true,
		},
		{
			name: "can modify operation with X-KDex-Function-Overwrite-Operation: true",
			r: func() *http.Request {
				it := httptest.NewRequest("GET", "/foo?foo=bar", http.NoBody)
				it.Header.Set("X-KDex-Function-Overwrite-Operation", "true")
				return it
			}(),
			functions: []kdexv1alpha1.KDexFunction{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "gen-foo",
						Namespace: "test-namespace",
					},
					Spec: kdexv1alpha1.KDexFunctionSpec{
						API: kdexv1alpha1.KDexOpenAPI{
							Description: "Auto-generated from request to /foo",
							Path:        "/foo",
							KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
								Get: raw(&openapi.Operation{
									Description: "GET /foo",
									OperationID: "gen-foo-get",
									Responses: openapi.NewResponses(
										openapi.WithStatus(200, &openapi.ResponseRef{
											Value: &openapi.Response{
												Description: openapi.Ptr("Successful response"),
											},
										}),
									),
								}),
							},
							Summary: "Auto-generated from request to /foo",
						},
						Metadata: kdexv1alpha1.KDexFunctionMetadata{
							AutoGenerated: true,
						},
					},
				},
			},
			want: &kdexv1alpha1.KDexFunction{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "gen-foo",
					Namespace: "test-namespace",
				},
				Spec: kdexv1alpha1.KDexFunctionSpec{
					API: kdexv1alpha1.KDexOpenAPI{
						Description: "Auto-generated from request to /foo",
						Path:        "/foo",
						KDexOpenAPIInternal: kdexv1alpha1.KDexOpenAPIInternal{
							Get: raw(&openapi.Operation{
								Description: "GET /foo",
								OperationID: "gen-foo-get",
								Parameters: openapi.Parameters{
									&openapi.ParameterRef{
										Value: &openapi.Parameter{
											Description: "Query parameter: foo",
											In:          "query",
											Name:        "foo",
											Required:    false,
											Schema: &openapi.SchemaRef{
												Value: &openapi.Schema{
													Type: &openapi.Types{openapi.TypeString},
												},
											},
										},
									},
								},
								Responses: openapi.NewResponses(
									openapi.WithStatus(200, &openapi.ResponseRef{
										Value: &openapi.Response{
											Description: openapi.Ptr("Successful response"),
										},
									}),
								),
								Summary: "gen-foo",
							}),
						},
						Summary: "Auto-generated from request to /foo",
					},
					Metadata: kdexv1alpha1.KDexFunctionMetadata{
						AutoGenerated: true,
					},
					Function: kdexv1alpha1.KDexFunctionExec{
						Language:    "go",
						Environment: "go-env",
					},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := RequestSniffer{
				Functions:     tt.functions,
				HostName:      "test-host",
				Namespace:     "test-namespace",
				SecurityModes: tt.securityModes,
			}

			got, gotErr := s.sniff(tt.r)

			if gotErr != nil {
				if !tt.wantErr {
					t.Errorf("sniff() failed: %v", gotErr)
				}
				return
			}
			if tt.wantErr {
				t.Fatal("sniff() succeeded unexpectedly")
			}
			assert.Equal(t, tt.want, got)
		})
	}
}
